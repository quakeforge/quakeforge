{
samplers = {
	samplers = {
		quakepic = {
			magFilter = nearest;
			minFilter = nearest;
			mipmapMode = nearest;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 0;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		glyph = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 0;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		palette_sampler = {
			magFilter = nearest;
			minFilter = nearest;
			mipmapMode = nearest;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 4;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		quakebsp_sampler = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = repeat;
			addressModeV = repeat;
			addressModeW = repeat;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 4;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		qskin_sampler = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 1000;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		sprite_sampler = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 1000;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
		shadow_sampler = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = true;
			compareOp = greater_or_equal;
			minLod = 0;
			maxLod = 1000;
			borderColor = float_opaque_white;
			unnormalizedCoordinates = false;
		};
		linear = {
			magFilter = linear;
			minFilter = linear;
			mipmapMode = linear;
			addressModeU = clamp_to_edge;
			addressModeV = clamp_to_edge;
			addressModeW = clamp_to_edge;
			mipLodBias = 0;
			anisotropyEnable = false;
			maxAnisotropy = 0;
			compareEnable = false;
			compareOp = always;
			minLod = 0;
			maxLod = 0;
			borderColor = float_transparent_black;
			unnormalizedCoordinates = false;
		};
	};
};
render_graph = {
	properties = {
		color = {
			bsp       = "[0.0, 0.5, 0.6, 1]";
			alias     = "[0.6, 0.5, 0.0, 1]";
			sprite    = "[0.6, 0.5, 0.0, 1]";
			particles = "[0.4, 0.5, 0.8, 1]";
			lights    = "[0.8, 0.6, 0.2, 1]";
			compose   = "[0.7, 0.7, 0.7, 1]";

			output    = "[0.0, 0.7, 0.7, 1]";
			waterwarp = "[0.0, 0.7, 0.7, 1]";
			fisheye   = "[0.0, 0.7, 0.7, 1]";
			slice     = "[0.8, 0.7, 0.2, 1]";
			lines     = "[0.8, 0.7, 0.4, 1]";
		};
		swapchain_dependency = {
			src = {
				stage = color_attachment_output;
				access = 0;
			};
			dst = {
				stage = color_attachment_output;
				access = color_attachment_write|color_attachment_read;
			};
		};
		color_dependency = {
			src = {
				stage = color_attachment_output;
				access = color_attachment_write;
			};
			dst = {
				stage = fragment_shader;
				access = input_attachment_read;
			};
			flags = by_region;
		};
		depth_dependency = {
			src = {
				stage = early_fragment_tests|late_fragment_tests;
				access = depth_stencil_attachment_write;
			};
			dst = {
				stage = fragment_shader|early_fragment_tests|late_fragment_tests;
				access = input_attachment_read|depth_stencil_attachment_read;
			};
			flags = by_region;
		};
		image_base = {
			imageType = `2d;
			samples = 1;
			extent = {
				width = $render_output.extent.width;
				height = $render_output.extent.height;
				depth = 1;
			};
			mipLevels = 1;
			arrayLayers = 1;
			tiling = optimal;
			usage = color_attachment|input_attachment|transient_attachment;
			initialLayout = undefined;
		};
		cube_image_base = {
			@inherit = $image_base;
			extent = {
				width = "min($render_output.extent.width,$render_output.extent.height)";
				height = "min($render_output.extent.width,$render_output.extent.height)";
				depth = 1;
			};
			arrayLayers = 6;
		};
		view_base = {
			viewType = `2d;
			components = {
				r = identity;
				g = identity;
				b = identity;
				a = identity;
			};
			subresourceRange = {
				aspectMask = color;
				levelCount = 1;
				layerCount = 1;
			};
		};
		cube_view_base = {
			@inherit = $view_base;
			viewType = `2d_array;
			subresourceRange = {
				layerCount = 6;
			};
		};
		attachment_base = {
			samples = 1;
			loadOp = dont_care;
			storeOp = none_ext;
			stencilLoadOp = dont_care;
			stencilStoreOp = none_ext;
			initialLayout = undefined;
			finalLayout = shader_read_only_optimal;
			clearValue = { color = "[0, 0, 0, 1]"; };
		};
		depth_base = {
			@inherit = $attachment_base;
			loadOp = clear;
			finalLayout = depth_stencil_read_only_optimal;
			clearValue = { depthStencil = { depth = 0; stencil = 0; }; };
		};

		no_cull = {
			depthClampEnable = false;
			rasterizerDiscardEnable = false;
			polygonMode = fill;
			cullMode = none;
			frontFace = counter_clockwise;
			depthBiasEnable = false;
			lineWidth = 1;
		};
		debug_poly_lines = {
			depthClampEnable = false;
			rasterizerDiscardEnable = false;
			polygonMode = line;
			cullMode = none;
			frontFace = clockwise;
			depthBiasEnable = false;
			lineWidth = 1;
		};
		cw_cull_back = {
			depthClampEnable = false;
			rasterizerDiscardEnable = false;
			polygonMode = fill;
			cullMode = back;
			frontFace = clockwise;
			depthBiasEnable = false;
			lineWidth = 1;
		};
		cw_cull_front = {
			depthClampEnable = false;
			rasterizerDiscardEnable = false;
			polygonMode = fill;
			cullMode = front;
			frontFace = clockwise;
			depthBiasEnable = false;
			lineWidth = 1;
		};
		counter_cw_cull_back = {
			depthClampEnable = false;
			rasterizerDiscardEnable = false;
			polygonMode = fill;
			cullMode = back;
			frontFace = counter_clockwise;
			depthBiasEnable = false;
			lineWidth = 1;
		};
		depth_test_and_write = {
			depthTestEnable = true;
			depthWriteEnable = true;
			depthCompareOp = greater_or_equal;
			depthBoundsTestEnable = false;
			stencilTestEnable = false;
		};
		depth_test_only = {
			depthTestEnable = true;
			depthWriteEnable = false;
			depthCompareOp = greater_or_equal;
			depthBoundsTestEnable = false;
			stencilTestEnable = false;
		};
		depth_test_only_reverse = {
			depthTestEnable = true;
			depthWriteEnable = false;
			depthCompareOp = greater;
			depthBoundsTestEnable = false;
			stencilTestEnable = false;
		};
		depth_disable = {
			depthTestEnable = false;
			depthWriteEnable = false;
			depthCompareOp = greater_or_equal;
			depthBoundsTestEnable = false;
			stencilTestEnable = false;
		};
		blend_disable = {
			blendEnable = false;
			srcColorBlendFactor = src_alpha;
			dstColorBlendFactor = one_minus_src_alpha;
			colorBlendOp = add;
			srcAlphaBlendFactor = src_alpha;
			dstAlphaBlendFactor = one_minus_src_alpha;
			alphaBlendOp = add;
			colorWriteMask = r|g|b|a;
		};
		alpha_blend = {
			blendEnable = true;
			srcColorBlendFactor = one;
			dstColorBlendFactor = one_minus_src_alpha;
			colorBlendOp = add;
			srcAlphaBlendFactor = one;
			dstAlphaBlendFactor = one_minus_src_alpha;
			alphaBlendOp = add;
			colorWriteMask = r|g|b|a;
		};
		additive_blend = {
			blendEnable = true;
			srcColorBlendFactor = one;
			dstColorBlendFactor = one;
			colorBlendOp = add;
			srcAlphaBlendFactor = zero;
			dstAlphaBlendFactor = one;
			alphaBlendOp = add;
			colorWriteMask = r|g|b|a;
		};
		pipeline_base = {
			viewport = {
				viewports = (
					{
						x = 0; y = 0;
						width = 640; height = 480;
						minDepth = 0; maxDepth = 1;
					}
				);
				scissors = (
					{
						offset = { x = 0; y = 0; };
						extent = { width = 640; height = 480; };
					},
				);
			};
			rasterization = $cw_cull_back;
			multisample = {
				rasterizationSamples = $msaaSamples;
				sampleShadingEnable = false;
				minSampleShading = 0.5f;
				alphaToCoverageEnable = false;
				alphaToOneEnable = false;
			};
			depthStencil = $depth_test_only;
			colorBlend = {
				logicOpEnable = false;
			};
			dynamic = {
				dynamicState = ( viewport, scissor );
			};
		};
		compose_base = {
			@inherit = $pipeline_base;
			rasterization = $counter_cw_cull_back;
			vertexInput = {
				bindings = ();
				attributes = ();
			};
			inputAssembly = {
				topology = triangle_list;
				primitiveRestartEnable = false;
			};
		};

		brush = {
			shader = {
				shadow_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/bsp_shadow.vert;
				};
				depth_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/bsp_depth.vert;
				};
				debug_fragment = {
					stage = fragment;
					name = main;
					module = $builtin/debug.frag;
				};
				gbuf_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/bsp_gbuf.vert;
				};
				gbuf_geometry = {
					stage = geometry;
					name = main;
					module = $builtin/bsp_gbuf.geom;
				};
				gbuf_fragment = {
					stage = fragment;
					name = main;
					module = $builtin/bsp_gbuf.frag;
				};
				quake_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/quakebsp.vert;
				};
				sky_specialization = {
					mapEntries = (
						// doSkyBox
						{ size = 4; offset = 0; constantID = 0; },
						// doSkySheet
						{ size = 4; offset = 4; constantID = 1; },
					);
				};
				skybox_fragment = {
					stage = fragment;
					name = main;
					module = $builtin/bsp_sky.frag;
					specializationInfo = {
						@inherit = $brush.shader.sky_specialization;
						// doSkyBox, doSkySheet
						data = "array(1, 0)";
					};
				};
				skysheet_fragment = {
					stage = fragment;
					name = main;
					module = $builtin/bsp_sky.frag;
					specializationInfo = {
						@inherit = $brush.shader.sky_specialization;
						// doSkyBox, doSkySheet
						data = "array(0, 1)";
					};
				};
				turb_fragment = {
					stage = fragment;
					name = main;
					module = $builtin/bsp_turb.frag;
				};
			};
			vertexInput = {
				bindings = (
					{ binding = 0; stride = "2 * 4 * 4"; inputRate = vertex; },
					{ binding = 1; stride = "4"; inputRate = instance; },
				);
				attributes = (
					{ location = 0; binding = 0; format = r32g32b32a32_sfloat; offset = 0;  },
					{ location = 1; binding = 0; format = r32g32b32a32_sfloat; offset = 16; },
					{ location = 2; binding = 1; format = r32_uint; offset = 0; },
				);
			};
			inputAssembly = {
				topology = triangle_fan;
				primitiveRestartEnable = true;
			};
			layout = {
				descriptorSets = (matrix_set, entity_set, oit_set,
				//				  surface      skybox
								  texture_set, texture_set);
				pushConstants = {
					fragment = {
						fog = vec4;
						time = float;
						alpha = float;
						turb_scale = float;
					};
				};
			};
			shadow_layout = {
				descriptorSets = (shadowmat_set, entity_set);
				pushConstants = {
					vertex = {
						MatrixBase = uint;
					};
				};
			};
		};
		alias = {
			shader = {
				shadow_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/mesh_shadow.r;
				};
				depth_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/mesh.r;
				};
				gbuf_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/mesh.r;
				};
			};
			vertexInput = {
				bindings = (
					{ binding = 0; stride = "2 * 4 * 4"; inputRate = vertex; },
					{ binding = 1; stride = "2 * 4 * 4"; inputRate = vertex; },
					{ binding = 2; stride = "2 * 4"; inputRate = vertex; },
				);
				attributes = (
					{ location = 0; binding = 0; format = r32g32b32a32_sfloat; offset = 0;  },
					{ location = 1; binding = 0; format = r32g32b32a32_sfloat; offset = 16; },
					{ location = 2; binding = 1; format = r32g32b32a32_sfloat; offset = 0;  },
					{ location = 3; binding = 1; format = r32g32b32a32_sfloat; offset = 16; },
					{ location = 4; binding = 2; format = r32g32_sfloat; offset = 0; },
				);
			};
			inputAssembly = {
				topology = triangle_list;
				primitiveRestartEnable = false;
			};
			layout = {
				//                            palette                skin
				descriptorSets = (matrix_set, texture_set, bone_set, texture_set);
				pushConstants = {
					vertex   = { Model = mat4; enabled_mask = uint; blend = float; };
					fragment = { colors = uint; base_color = vec4; fog = vec4; };
				};
			};
			shadow_layout = {
				descriptorSets = (shadowmat_set, bone_set);
				pushConstants = {
					vertex = { Model = mat4; enabled_mask = uint; blend = float; MatrixBase = uint; };
				};
			};
		};
		qskin = {
			shader = {
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/qskin_gbuf.frag;
				};
			};
		};
		iqm = {
			shader = {
				specialization = {
					mapEntries = (
						// IQMDepthOnly
						{ size = 4; offset = 0; constantID = 0; },
					);
				};
				shadow_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/iqm_shadow.vert;
					specializationInfo = {
						@inherit = $iqm.shader.specialization;
						// IQMDepthOnly
						data = "array(1)";
					};
				};
				depth_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/iqm.vert;
					specializationInfo = {
						@inherit = $iqm.shader.specialization;
						// IQMDepthOnly
						data = "array(1)";
					};
				};
				gbuf_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/iqm.vert;
					specializationInfo = {
						@inherit = $iqm.shader.specialization;
						// IQMDepthOnly
						data = "array(0)";
					};
				};
			};
			vertexInput = {
				bindings = (
					{ binding = 0; stride = 20; inputRate = vertex; },
					{ binding = 1; stride = 40; inputRate = vertex; },
				);
				attributes = (
					{ location = 0; binding = 0; format = r32g32b32_sfloat;    offset = 0;  },	// position
					{ location = 1; binding = 0; format = r8g8b8a8_uint;       offset = 12; },	// bonindices
					{ location = 2; binding = 0; format = r8g8b8a8_unorm;      offset = 16; },	// boneweights

					{ location = 3; binding = 1; format = r32g32_sfloat;       offset = 0;  },	// texcoord
					{ location = 4; binding = 1; format = r32g32b32_sfloat;    offset = 8;  },	// normal
					{ location = 5; binding = 1; format = r32g32b32a32_sfloat; offset = 20; },	// tangent
					{ location = 6; binding = 1; format = r8g8b8a8_unorm;      offset = 36; },	// color

				);
			};
			inputAssembly = {
				topology = triangle_list;
				primitiveRestartEnable = false;
			};
			layout = {
				//                            palette      skin
				descriptorSets = (matrix_set, texture_set, texture_set, bone_set);
				pushConstants = {
					vertex   = { Model = mat4; blend = float; };
					fragment = { colors = uint; base_color = vec4; fog = vec4; };
				};
			};
			shadow_layout = {
				//                               palette(n/u) skin(n/u)
				descriptorSets = (shadowmat_set, texture_set, texture_set, bone_set);
				pushConstants = {
					vertex   = { Model = mat4; blend = float; MatrixBase = uint; };
				};
			};
		};
		sprite = {
			shader = {
				depth_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/sprite_depth.vert;
				};
				depth_fragment = {
					stage = fragment;
					name = main;
					module = $builtin/sprite_depth.frag;
				};
				gbuf_vertex = {
					stage = vertex;
					name = main;
					module = $builtin/sprite_gbuf.vert;
				};
				gbuf_fragment = {
					stage = fragment;
					name = main;
					module = $builtin/sprite_gbuf.frag;
				};
			};
			vertexInput = {
				bindings = ();
				attributes = ();
			};
			inputAssembly = {
				topology = triangle_strip;
				// never draw more than 4 verts
				primitiveRestartEnable = false;
			};
			layout = {
				descriptorSets = (matrix_set, sprite_set);
				pushConstants = {
					vertex   = {
						Model = mat4;
						frame = int;
					};
					fragment = {
						overlap   = { offset = 64; type = int; };
						frame     = int;
						spriteind = int;
						fog       = vec4;
					};
				};
			};
		};
		particle = {
			shader = {
				vertex = {
					stage = vertex;
					name = main;
					module = $builtin/particle.vert;
				};
				geometry = {
					stage = geometry;
					name = main;
					module = $builtin/particle.geom;
				};
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/particle.frag;
				};
			};
			vertexInput = {
				bindings = (
					{ binding = 0; stride = "4 * 4 * 4"; inputRate = instance; },
				);
				attributes = (
					{ location = 0; binding = 0; format = r32g32b32a32_sfloat; offset = 0;  },
					{ location = 1; binding = 0; format = r32g32b32a32_sfloat; offset = 16; },
					{ location = 2; binding = 0; format = r32g32b32a32_sfloat; offset = 32; },
					{ location = 3; binding = 0; format = r32g32b32a32_sfloat; offset = 48; },
				);
			};
			inputAssembly = {
				topology = point_list;
				primitiveRestartEnable = false;
			};
			layout = {
				draw = {
					//                            palette
					descriptorSets = (matrix_set, texture_set, oit_set);
					pushConstants = {
						vertex = { Model = mat4; };
						fragment = { fog = vec4; };
					};
				};
				physics = {
					descriptorSets = (particle_set);
					pushConstants = {
						compute = { gravity = vec4; dT = float; };
					};
				};
				update = {
					//                cur           in            new
					descriptorSets = (particle_set, particle_set, particle_set);
				};
			};
		};
		fstriangle = {
			shader = {
				vertex = {
					stage = vertex;
					name = main;
					module = $builtin/fstriangle.vert;
				};
				vertexst = {
					stage = vertex;
					name = main;
					module = $builtin/fstrianglest.vert;
				};
			};
		};
		gridplane = {
			shader = {
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/gridplane.frag;
				};
			};
			layout = {
				descriptorSets = (matrix_set, planes_set);
			};
		};
		general = {
			shader = {
				fragment_entid = {
					stage = fragment;
					name = main;
					module = $builtin/entid.frag;
				};
			};
		};
		lighting = {
			shader = {
				vertex_splat = {
					stage = vertex;
					name = main;
					module = $builtin/light_splat.vert;
				};
				vertex_entid = {
					stage = vertex;
					name = main;
					module = $builtin/light_entid.vert;
				};
				vertex_flat = {
					stage = vertex;
					name = main;
					module = $builtin/light_flat.vert;
				};
				fragment_splat = {
					stage = fragment;
					name = main;
					module = $builtin/light_splat.frag;
				};
				fragment_none = {
					stage = fragment;
					name = main;
					module = $builtin/lighting_none.frag;
				};
				fragment_plane = {
					stage = fragment;
					name = main;
					module = $builtin/lighting_plane.frag;
				};
				fragment_cascade = {
					stage = fragment;
					name = main;
					module = $builtin/lighting_cascade.frag;
				};
				fragment_cube = {
					stage = fragment;
					name = main;
					module = $builtin/lighting_cube.frag;
				};
				debug_fragment = {
					stage = fragment;
					name = main;
					module = $builtin/light_debug.frag;
				};
				debug_oit = {
					stage = fragment;
					name = main;
					module = $builtin/light_oit.frag;
				};
			};
			vertexInput_splat = {
				bindings = (
					{ binding = 0; stride = "4"; inputRate = instance; },
					{ binding = 1; stride = "4"; inputRate = instance; },
					{ binding = 2; stride = "3 * 4"; inputRate = vertex; },
				);
				attributes = (
					{ location = 0; binding = 0; format = r32_uint; offset = 0; },
					{ location = 1; binding = 1; format = r32_sfloat; offset = 0; },
					{ location = 2; binding = 2; format = r32g32b32_sfloat; offset = 0;  },
				);
			};
			vertexInput_flat = {
				bindings = (
					{ binding = 0; stride = "4"; inputRate = instance; },
				);
				attributes = (
					{ location = 0; binding = 0; format = r32_uint; offset = 0; },
				);
			};
			inputAssembly = {
				topology = triangle_fan;
				primitiveRestartEnable = true;
			};
			splat_layout = {
				descriptorSets = (matrix_set, lighting_lights);
			};
			splat_oit_layout = {
				descriptorSets = (matrix_set, lighting_lights, oit_set);
			};
			layout = {
				descriptorSets = (shadowmat_set, lighting_lights,
								  lighting_attach, lighting_shadow);
				pushConstants = {
					fragment = {
						fog = vec4;
						CascadeDepths = vec4;
						queue = uint;
					};
				};
			};
		};
		compose = {
			shader = {
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/compose.frag;
				};
			};
			layout = {
				descriptorSets = (compose_attach, oit_set);
				pushConstants = {
					fragment = {
						fog = vec4;
						camera = vec4;
					};
				};
			};
		};
		output = {
			@inherit = $compose_base;
			shader = {
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/output.frag;
				};
			};
			layout = {
				descriptorSets = (matrix_set, output_set);
			};
		};
		waterwarp = {
			@inherit = $compose_base;
			shader = {
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/waterwarp.frag;
				};
			};
			layout = {
				descriptorSets = (matrix_set, output_set);
				pushConstants = {
					fragment = { time = float; };
				};
			};
		};
		fisheye = {
			@inherit = $compose_base;
			shader = {
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/fisheye.frag;
				};
			};
			layout = {
				descriptorSets = (matrix_set, output_set);
				pushConstants = {
					fragment = { fov = float; aspect = float; };
				};
			};
		};
		slice = {
			shader = {
				vertex = {
					stage = vertex;
					name = main;
					module = $builtin/slice.vert;
				};
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/twod.frag;
				};
			};
			vertexInput = {
				bindings = (
					{ binding = 0; stride = "4 + 4 + 4*4"; inputRate = instance; },
				);
				attributes = (
					// 9-slice index
					{ location = 0; binding = 0; format = r32_uint;       offset = 0; },
					// 9-slice color
					{ location = 1; binding = 0; format = r8g8b8a8_unorm; offset = 4; },
					// 9-slice position (2d)
					{ location = 2; binding = 0; format = r32g32_sfloat;  offset = 8; },
					// 9-slice size delta (2d)
					{ location = 3; binding = 0; format = r32g32_sfloat;  offset = 16; },
				);
			};
			inputAssembly = {
				topology = triangle_strip;
				primitiveRestartEnable = true;
			};
			layout = {
				descriptorSets = (matrix_set, quad_data_set);
			};
		};
		lines = {
			shader = {
				vertex = {
					stage = vertex;
					name = main;
					module = $builtin/line.vert;
				};
				fragment = {
					stage = fragment;
					name = main;
					module = $builtin/line.frag;
				};
			};
			vertexInput = {
				bindings = (
					{ binding = 0; stride = "2 * 4 + 4"; inputRate = vertex; },
				);
				attributes = (
					{ location = 0; binding = 0; format = r32g32_sfloat;  offset = 0; },
					{ location = 1; binding = 0; format = r8g8b8a8_unorm; offset = 8; },
				);
			};
			inputAssembly = {
				topology = line_list;
				primitiveRestartEnable = false;
			};
			layout = {
				descriptorSets = (matrix_set);
			};
		};
	};
	descriptorSetLayouts = {
		matrix_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex|geometry|fragment;
				},
			);
		};
		shadowmat_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = vertex|fragment;
				},
				{
					binding = 1;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
			);
		};
		quad_data_set = {
			bindings = (
				{
					// glyph texture data
					binding = 0;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					// glyph geometry data (offset and uv)
					binding = 1;
					descriptorType = uniform_texel_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
			);
		};
		texture_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment|vertex;
				},
			);
		};
		oit_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 1;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 2;
					descriptorType = storage_image;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		entity_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
			);
		};
		bone_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
			);
		};
		planes_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		sprite_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = uniform_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
				{
					binding = 1;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		lighting_attach = {
			bindings = (
				{
					binding = 0;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 1;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 2;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 3;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		lighting_lights = {
			bindings = (
				{
					binding = 0;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = vertex|fragment;
				},
				{
					binding = 1;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = vertex|fragment;
				},
				{
					binding = 2;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 3;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 4;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = vertex;
				},
			);
		};
		lighting_shadow = {
			bindings = (
				{
					binding = 0;
					descriptorType = combined_image_sampler;
					descriptorCount = 32;
					stageFlags = fragment;
				},
			);
		};
		compose_attach = {
			bindings = (
				{
					binding = 0;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 1;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 2;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
				{
					binding = 3;
					descriptorType = input_attachment;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
		particle_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = compute;
				},
				{
					binding = 1;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = compute;
				},
				{
					binding = 2;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = compute;
				},
			);
		};
		particle_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = compute;
				},
				{
					binding = 1;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = compute;
				},
				{
					binding = 2;
					descriptorType = storage_buffer;
					descriptorCount = 1;
					stageFlags = compute;
				},
			);
		};
		output_set = {
			bindings = (
				{
					binding = 0;
					descriptorType = combined_image_sampler;
					descriptorCount = 1;
					stageFlags = fragment;
				},
			);
		};
	};
	images = {
		occlusion_depth = {
			@inherit = $image_base;
			format = d32_sfloat;
			usage = depth_stencil_attachment|input_attachment|transient_attachment;
		};
		depth = {
			@inherit = $image_base;
			format = d32_sfloat;
			usage = depth_stencil_attachment|input_attachment|transient_attachment;
		};
		color = {
			@inherit = $image_base;
			format = r8g8b8a8_unorm;
		};
		emission = {
			@inherit = $image_base;
			format = r16g16b16a16_sfloat;
		};
		normal = {
			@inherit = $image_base;
			format = r16g16b16a16_sfloat;
		};
		position = {
			@inherit = $image_base;
			format = r32g32b32a32_sfloat;
		};
		light = {
			@inherit = $image_base;
			format = r16g16b16a16_sfloat;
		};
		output = {
			@inherit = $image_base;
			usage = color_attachment|input_attachment|sampled;
			format = $render_output.format;
		};
		entid = {
			@inherit = $image_base;
			usage = color_attachment|transfer_src;
			format = r32_uint;
		};

		occlusion_cube_depth = {
			@inherit = $cube_image_base;
			format = d32_sfloat;
			usage = depth_stencil_attachment|input_attachment|transient_attachment;
		};
		cube_depth = {
			@inherit = $cube_image_base;
			format = d32_sfloat;
			usage = depth_stencil_attachment|input_attachment|transient_attachment;
		};
		cube_color = {
			@inherit = $cube_image_base;
			format = r8g8b8a8_unorm;
		};
		cube_emission = {
			@inherit = $cube_image_base;
			format = r16g16b16a16_sfloat;
		};
		cube_normal = {
			@inherit = $cube_image_base;
			format = r16g16b16a16_sfloat;
		};
		cube_position = {
			@inherit = $cube_image_base;
			format = r32g32b32a32_sfloat;
		};
		cube_light = {
			@inherit = $cube_image_base;
			format = r16g16b16a16_sfloat;
		};
		cube_output = {
			@inherit = $cube_image_base;
			flags = cube_compatible;
			usage = color_attachment|input_attachment|sampled;
			format = $render_output.format;
		};
		cube_entid = {
			@inherit = $cube_image_base;
			usage = color_attachment|transfer_src;
			format = r32_uint;
		};
	};
	imageviews = {
		occlusion_depth = {
			@inherit = $view_base;
			image = occlusion_depth;
			format = $images.occlusion_depth.format;
			subresourceRange = {
				aspectMask = depth;
			};
		};
		depth = {
			@inherit = $view_base;
			image = depth;
			format = $images.depth.format;
			subresourceRange = {
				aspectMask = depth;
			};
		};
		color = {
			@inherit = $view_base;
			image = color;
			format = $images.color.format;
		};
		emission = {
			@inherit = $view_base;
			image = emission;
			format = $images.emission.format;
		};
		normal = {
			@inherit = $view_base;
			image = normal;
			format = $images.normal.format;
		};
		position = {
			@inherit = $view_base;
			image = position;
			format = $images.position.format;
		};
		light = {
			@inherit = $view_base;
			image = light;
			format = $images.light.format;
		};
		output = {
			@inherit = $view_base;
			image = output;
			format = $render_output.format;
		};
		entid = {
			@inherit = $view_base;
			image = entid;
		};
		occlusion_cube_depth = {
			@inherit = $cube_view_base;
			image = occlusion_cube_depth;
			format = $images.occlusion_cube_depth.format;
			subresourceRange = {
				aspectMask = depth;
			};
		};
		cube_depth = {
			@inherit = $cube_view_base;
			image = cube_depth;
			format = $images.cube_depth.format;
			subresourceRange = {
				aspectMask = depth;
			};
		};
		cube_color = {
			@inherit = $cube_view_base;
			image = cube_color;
			format = $images.cube_color.format;
		};
		cube_emission = {
			@inherit = $cube_view_base;
			image = cube_emission;
			format = $images.cube_emission.format;
		};
		cube_normal = {
			@inherit = $cube_view_base;
			image = cube_normal;
			format = $images.cube_normal.format;
		};
		cube_position = {
			@inherit = $cube_view_base;
			image = cube_position;
			format = $images.cube_position.format;
		};
		cube_light = {
			@inherit = $cube_view_base;
			image = cube_light;
			format = $images.cube_light.format;
		};
		cube_output = {
			@inherit = $cube_view_base;
			viewType = cube;
			image = cube_output;
			format = $render_output.format;
		};
		cube_entid = {
			@inherit = $cube_view_base;
			image = cube_entid;
		};
	};
	output = {
		view = $output;
		format = r16g16b16a16_sfloat;
		finalLayout = shader_read_only_optimal;
	};
	renderpasses = {
		occlusion = {
			color = "[0.8, 0.6, 0, 1]";
			framebuffer = {
				width = $render_output.extent.width;
				height = $render_output.extent.height;
				layers = 1;
				attachments = {
					depth = {
						@inherit = $depth_base;
						format = $images.depth.format;
						view = occlusion_depth;
					};
				};
			};
			subpasses = {
				depth = {
					color = "[ 0.5,  0.5,  0.5, 1]";
					attachments = {
						depth = {
							depth = depth_stencil_attachment_optimal;
						};
					};

					base_pipeline = {
						@inherit = $pipeline_base;
						depthStencil = $depth_test_and_write;
						rasterization = $cw_cull_back;
					};
					pipelines = {
						bsp:depth = {
							color = $color.bsp;
							tasks = (
								{ func = bsp_draw_queue;
								  params = (main, solid, 0); },
								{ func = bsp_draw_queue;
								  params = (main, sky, 0); },
							);

							stages = (
								$brush.shader.depth_vertex,
							);
							vertexInput = {
								bindings = (
									"$brush.vertexInput.bindings[0]",
									"$brush.vertexInput.bindings[1]",
								);
								attributes = (
									"$brush.vertexInput.attributes[0]",
									"$brush.vertexInput.attributes[2]",
								);
							};
							inputAssembly = $brush.inputAssembly;
							layout = $brush.layout;
						};
					};
				};
				lightcull = {
					color = "[ 0.7,  0.5,  0, 1]";
					dependencies = {
						depth = $depth_dependency;
					};
					attachments = {
						depth = {
							depth = depth_stencil_attachment_optimal;
						};
					};

					base_pipeline = {
						@inherit = $pipeline_base;
						depthStencil = $depth_test_only;
						rasterization = $cw_cull_back;
					};
					pipelines = {
						cull_lights = {
							@inherit = $compose_base;

							color = $color.lights;
							tasks = (
								{ func = lighting_bind_descriptors;
								  params = (hull, none); },
								{ func = lighting_draw_hulls; },
							);

							stages = (
								$lighting.shader.vertex_splat,
							);
							vertexInput = $lighting.vertexInput_splat;
							inputAssembly = $lighting.inputAssembly;
							layout = $lighting.splat_layout;
							rasterization = $counter_cw_cull_back;
							depthStencil = $depth_test_only;
						};
					};
				};
			};
		};
		occlusion_cube = {
			@inherit = $renderpasses.occlusion;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3fu, 0x3fu);
			});
			framebuffer = {
				width = "min($render_output.extent.width,$render_output.extent.height)";
				height = "min($render_output.extent.width,$render_output.extent.height)";
				layers = 1;
				attachments = {
					depth = {
						@inherit = $depth_base;
						format = $images.cube_depth.format;
						view = occlusion_cube_depth;
					};
				};
			};
		};
		deferred = {
			color = "[0, 1, 0, 1]";
			framebuffer = {
				width = $render_output.extent.width;
				height = $render_output.extent.height;
				layers = 1;
				attachments = {
					depth = {
						@inherit = $depth_base;
						format = $images.depth.format;
						view = depth;
					};
					color = {
						@inherit = $attachment_base;
						format = $images.color.format;
						loadOp = clear;
						view = color;
					};
					emission = {
						@inherit = $attachment_base;
						format = $images.emission.format;
						loadOp = clear;
						view = emission;
					};
					normal = {
						@inherit = $attachment_base;
						format = $images.normal.format;
						view = normal;
					};
					position = {
						@inherit = $attachment_base;
						format = $images.position.format;
						view = position;
					};
					light = {
						@inherit = $attachment_base;
						format = $images.light.format;
						loadOp = clear;
						view = light;
					};
					entid = {
						@inherit = $attachment_base;
						format = $images.entid.format;
						loadOp = clear;
						storeOp = store;
						finalLayout = transfer_src_optimal;
						clearValue = {
							color = { int32 = ( -1, -1, -1, -1); };
						};
						view = entid;
					};
					output = {
						@inherit = $attachment_base;
						format = $render_output.format;
						loadOp = clear;
						storeOp = store;
						finalLayout = $render_output.finalLayout;
						view = output;
					};
				};
			};
			subpasses = {
				depth = {
					color = "[ 0.5,  0.5,  0.5, 1]";
					attachments = {
						depth = {
							depth = depth_stencil_attachment_optimal;
						};
						preserve = (color, emission, normal, position, output);
					};

					base_pipeline = {
						@inherit = $pipeline_base;
						depthStencil = $depth_test_and_write;
						rasterization = $cw_cull_back;
					};
					pipelines = {
						bsp:depth = {
							color = $color.bsp;
							tasks = (
								{ func = bsp_draw_queue;
								  params = (main, solid, 0); },
								{ func = bsp_draw_queue;
								  params = (main, sky, 0); },
							);

							stages = (
								$brush.shader.depth_vertex,
							);
							vertexInput = {
								bindings = (
									"$brush.vertexInput.bindings[0]",
									"$brush.vertexInput.bindings[1]",
								);
								attributes = (
									"$brush.vertexInput.attributes[0]",
									"$brush.vertexInput.attributes[2]",
								);
							};
							inputAssembly = $brush.inputAssembly;
							layout = $brush.layout;
						};
						alias:depth = {
							color = $color.alias;
							tasks = (
								{ func = alias_draw;
								  params = (main, 0); },
							);

							stages = (
								$alias.shader.depth_vertex,
							);
							vertexInput = {
								// depth pass doesn't use UVs
								bindings = (
									"$alias.vertexInput.bindings[0]",
									"$alias.vertexInput.bindings[1]",
								);
								attributes = (
									"$alias.vertexInput.attributes[0]",
									"$alias.vertexInput.attributes[1]",
									"$alias.vertexInput.attributes[2]",
									"$alias.vertexInput.attributes[3]",
								);
							};
							inputAssembly = $alias.inputAssembly;
							layout = $alias.layout;
							dynamic = {
								dynamicState = (
									viewport,
									scissor,
									vertex_input_ext,
								);
							};
						};
						sprite:depth = {
							color = $color.sprite;
							tasks = (
								{ func = sprite_draw; },
							);

							stages = (
								$sprite.shader.depth_vertex,
								$sprite.shader.depth_fragment,
							);
							vertexInput = $sprite.vertexInput;
							inputAssembly = $sprite.inputAssembly;
							layout = $sprite.layout;
						};
					};
				};
				translucent = {
					color = "[ 0.25, 0.25, 0.6, 1]";
					dependencies = {
						depth = $depth_dependency;
					};
					attachments = {
						depth = {
							depth = depth_stencil_read_only_optimal;
						};
						preserve = (color, emission, normal, position, output);
					};
					base_pipeline = {
						@inherit = $pipeline_base;
						rasterization = $cw_cull_back;
					};
					pipelines = {
						bsp:skybox = {
							color = $color.bsp;
							tasks = (
								// FIXME sky should not use OIT
								{ func = bsp_draw_queue;
								  params = (main, sky, 1); },
							);

							stages = (
								$brush.shader.quake_vertex,
								$brush.shader.skybox_fragment,
							);
							vertexInput = $brush.vertexInput;
							inputAssembly = $brush.inputAssembly;
							layout = $brush.layout;
						};
						bsp:skysheet = {
							color = $color.bsp;
							tasks = (
								// FIXME sky should not use OIT
								{ func = bsp_draw_queue;
								  params = (main, sky, 1); },
							);

							stages = (
								$brush.shader.quake_vertex,
								$brush.shader.skysheet_fragment,
							);
							vertexInput = $brush.vertexInput;
							inputAssembly = $brush.inputAssembly;
							layout = $brush.layout;
						};
						bsp:trans = {
							color = $color.bsp;
							tasks = (
								{ func = bsp_draw_queue;
								  params = (main, translucent, 1); },
								{ func = bsp_draw_queue;
								  params = (main, turbulent, 1); },
							);

							stages = (
								$brush.shader.quake_vertex,
								$brush.shader.turb_fragment,
							);
							vertexInput = $brush.vertexInput;
							inputAssembly = $brush.inputAssembly;
							layout = $brush.layout;
						};
						particles:trans = {
							color = $color.particles;
							tasks = (
								{ func = particles_draw; },
							);

							stages = (
								$particle.shader.vertex,
								$particle.shader.geometry,
								$particle.shader.fragment,
							);
							vertexInput = $particle.vertexInput;
							inputAssembly = $particle.inputAssembly;
							layout = $particle.layout.draw;
						};
						debug_lights = {
							@inherit = $compose_base;
							disabled = true;

							color = $color.lights;
							tasks = (
								{ func = lighting_bind_descriptors;
								  params = (hull, plane); },
								{ func = lighting_draw_splats; },
							);

							stages = (
								$lighting.shader.vertex_splat,
								$lighting.shader.debug_oit,
							);
							vertexInput = $lighting.vertexInput_splat;
							inputAssembly = $lighting.inputAssembly;
							layout = $lighting.splat_oit_layout;
							rasterization = $counter_cw_cull_back;
							depthStencil = $depth_test_only;
						};
					};
				};
				gbuffer = {
					color = "[ 0.3,  0.7,  0.3, 1]";
					dependencies = {
						depth = $depth_dependency;
						translucent = $depth_dependency;//FIXME why?
					};
					attachments = {
						color = {
							color = {
								layout = color_attachment_optimal;
								blend = $blend_disable;
							};
							emission = {
								layout = color_attachment_optimal;
								blend = $blend_disable;
							};
							normal = {
								layout = color_attachment_optimal;
								blend = $blend_disable;
							};
							position = {
								layout = color_attachment_optimal;
								blend = $blend_disable;
							};
						};
						depth = {
							depth = depth_stencil_read_only_optimal;
						};
						preserve = (output);
					};
					base_pipeline = {
						@inherit = $pipeline_base;
						rasterization = $cw_cull_back;
					};
					pipelines = {
						bsp:gbuffer = {
							color = $color.bsp;
							tasks = (
								{ func = bsp_draw_queue;
								  params = (main, solid, 1); },
							);

							stages = (
								$brush.shader.gbuf_vertex,
								$brush.shader.gbuf_geometry,
								$brush.shader.gbuf_fragment,
							);
							vertexInput = $brush.vertexInput;
							inputAssembly = $brush.inputAssembly;
							layout = $brush.layout;
						};
						alias:gbuffer = {
							color = $color.alias;
							tasks = (
								{ func = alias_draw;
								  params = (main, 1); },
							);

							stages = (
								$alias.shader.gbuf_vertex,
								$qskin.shader.fragment,
							);
							vertexInput = $alias.vertexInput;
							inputAssembly = $alias.inputAssembly;
							layout = $alias.layout;
							dynamic = {
								dynamicState = (
									viewport,
									scissor,
									vertex_input_ext,
								);
							};
						};
						sprite:gbuffer = {
							color = $color.sprite;
							tasks = (
								{ func = sprite_draw; },
							);

							stages = (
								$sprite.shader.gbuf_vertex,
								$sprite.shader.gbuf_fragment,
							);
							vertexInput = $sprite.vertexInput;
							inputAssembly = $sprite.inputAssembly;
							layout = $sprite.layout;
						};
					};
				};
				lighting = {
					color = "[ 0.8,  0.8,  0.8, 1]";
					dependencies = {
						gbuffer = $color_dependency;
					};
					attachments = {
						input = {
							color = shader_read_only_optimal;
							emission = shader_read_only_optimal;
							normal = shader_read_only_optimal;
							position = shader_read_only_optimal;
						};
						color = {
							light = {
								layout = color_attachment_optimal;
								blend = $additive_blend;
							};
						};
						preserve = (depth, output);
					};
					pipelines = {
						lights_none = {
							@inherit = $compose_base;

							color = $color.lights;
							tasks = (
								{ func = lighting_bind_descriptors;
								  params = (main, none); },
								{ func = lighting_draw_lights;
								  params = (main, none); },
							);

							stages = (
								$fstriangle.shader.vertex,
								$lighting.shader.fragment_none,
							);
							layout = $lighting.layout;
						};
						lights_plane = {
							@inherit = $compose_base;

							color = $color.lights;
							tasks = (
								{ func = lighting_bind_descriptors;
								  params = (main, plane); },
								{ func = lighting_draw_lights;
								  params = (main, plane); },
							);

							stages = (
								$fstriangle.shader.vertex,
								$lighting.shader.fragment_plane,
							);
							layout = $lighting.layout;
						};
						lights_cascade = {
							@inherit = $compose_base;

							color = $color.lights;
							tasks = (
								{ func = lighting_bind_descriptors;
								  params = (main, cascade); },
								{ func = lighting_draw_lights;
								  params = (main, cascade); },
							);

							stages = (
								$fstriangle.shader.vertex,
								$lighting.shader.fragment_cascade,
							);
							layout = $lighting.layout;
						};
						lights_cube = {
							@inherit = $compose_base;

							color = $color.lights;
							tasks = (
								{ func = lighting_bind_descriptors;
								  params = (main, cube); },
								{ func = lighting_draw_lights;
								  params = (main, cube); },
							);

							stages = (
								$fstriangle.shader.vertex,
								$lighting.shader.fragment_cube,
							);
							layout = $lighting.layout;
						};
					};
				};
				compose = {
					color = "[ 0.7,  0.3,  0.3, 1]";
					dependencies = {
						lighting = $color_dependency;
					};
					attachments = {
						input = {
							color = shader_read_only_optimal;
							light = shader_read_only_optimal;
							emission = shader_read_only_optimal;
							position = shader_read_only_optimal;
						};
						color = {
							output = {
								layout = color_attachment_optimal;
								blend = $additive_blend;
							};
						};
						preserve = (depth, normal);
					};
					pipelines = {
						compose = {
							@inherit = $compose_base;

							color = $color.compose;
							tasks = (
								{ func = compose_draw;
								  params = (0); },
							);

							stages = (
								$fstriangle.shader.vertex,
								$compose.shader.fragment,
							);
							layout = $compose.layout;
						};
						debug_bsp = {
							@inherit = $compose_base;
							disabled = true;

							color = $color.bsp;
							tasks = (
								{ func = bsp_visit_world;
								  params = (debug); },
								{ func = bsp_draw_queue;
								  params = (debug, solid, 0); },
								{ func = bsp_draw_queue;
								  params = (debug, sky, 0); },
								{ func = bsp_draw_queue;
								  params = (debug, translucent, 0); },
								{ func = bsp_draw_queue;
								  params = (debug, turbulent, 0); },
							);

							stages = (
								$brush.shader.depth_vertex,
								$brush.shader.debug_fragment,
							);
							vertexInput = {
								bindings = (
									"$brush.vertexInput.bindings[0]",
									"$brush.vertexInput.bindings[1]",
								);
								attributes = (
									"$brush.vertexInput.attributes[0]",
									"$brush.vertexInput.attributes[2]",
								);
							};
							inputAssembly = $brush.inputAssembly;
							layout = $brush.layout;
							rasterization = $debug_poly_lines;
							depthStencil = $depth_disable;
						};
						debug_lights = {
							@inherit = $compose_base;
							disabled = true;

							color = $color.lights;
							tasks = (
								{ func = lighting_bind_descriptors;
								  params = (hull, none); },
								{ func = lighting_draw_splats; },
							);

							stages = (
								$lighting.shader.vertex_splat,
								$lighting.shader.debug_fragment,
							);
							vertexInput = $lighting.vertexInput_splat;
							inputAssembly = $lighting.inputAssembly;
							layout = $lighting.splat_layout;
							rasterization = $debug_poly_lines;
							depthStencil = $depth_disable;
						};
						debug_planes = {
							@inherit = $compose_base;
							disabled = false;

							color = $color.lights;
							tasks = (
								{ func = debug_planes_draw; },
							);

							stages = (
								$fstriangle.shader.vertexst,
								$gridplane.shader.fragment,
							);
							layout = $gridplane.layout;
							depthStencil = $depth_disable;
						};
					};
				};
				entid = {
					color = "[ 1,  0,  0, 1]";
					dependencies = {
						depth = $depth_dependency;
					};
					attachments = {
						color = {
							entid = {
								layout = color_attachment_optimal;
								blend = $blend_disable;
							};
						};
						preserve = (depth, normal, position, output);
					};
					pipelines = {
						entid_lights = {
							@inherit = $compose_base;
							disabled = false;

							color = $color.lights;
							tasks = (
								{ func = lighting_bind_descriptors;
								  params = (hull, none); },
								{ func = lighting_draw_splats; },
							);

							stages = (
								$lighting.shader.vertex_entid,
								$general.shader.fragment_entid,
							);
							vertexInput = $lighting.vertexInput_splat;
							inputAssembly = $lighting.inputAssembly;
							layout = $lighting.splat_layout;
							rasterization = $debug_poly_lines;
							depthStencil = $depth_disable;
						};
					};
				};
				$external = {
					dependencies = {
						compose = {
							src = {
								stage = color_attachment_output;
								access = color_attachment_write;
							};
							dst = {
								stage = fragment_shader;
								access = shader_read;
							};
						}
					};
				};
			};
			output = output;
		};
		deferred_cube = {
			@inherit = $renderpasses.deferred;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3fu, 0x3fu, 0x3fu, 0x3fu, 0x3fu, 0x3fu);
			});
			framebuffer = {
				width = "min($render_output.extent.width,$render_output.extent.height)";
				height = "min($render_output.extent.width,$render_output.extent.height)";
				layers = 1;
				attachments = {
					depth = {
						@inherit = $depth_base;
						format = $images.cube_depth.format;
						view = cube_depth;
					};
					color = {
						@inherit = $attachment_base;
						format = $images.cube_color.format;
						loadOp = clear;
						view = cube_color;
					};
					emission = {
						@inherit = $attachment_base;
						format = $images.cube_emission.format;
						loadOp = clear;
						view = cube_emission;
					};
					normal = {
						@inherit = $attachment_base;
						format = $images.cube_normal.format;
						view = cube_normal;
					};
					position = {
						@inherit = $attachment_base;
						format = $images.cube_position.format;
						view = cube_position;
						clearValue = {
							color = { int32 = ( 0, 0, 0, 0); };
						};
					};
					light = {
						@inherit = $attachment_base;
						format = $images.cube_light.format;
						view = cube_light;
					};
					entid = {
						@inherit = $attachment_base;
						format = $images.cube_entid.format;
						loadOp = clear;
						storeOp = store;
						finalLayout = transfer_src_optimal;
						clearValue = {
							color = { int32 = ( -1, -1, -1, -1); };
						};
						view = cube_entid;
					};
					output = {
						@inherit = $attachment_base;
						format = $render_output.format;
						loadOp = clear;
						storeOp = store;
						finalLayout = $render_output.finalLayout;
						view = cube_output;
					};
				};
			};
			output = cube_output;
		};
		output = {
			color = "[0, 1, 1, 1]";
			framebuffer = {
				layers = 1;
				attachments = {
					output = $swapchain;
				};
			};
			subpasses = {
				compose = {
					color = "[ 0,  0.5,  0.5, 1]";
					dependencies = {
						$external = $swapchain_dependency;
					};
					attachments = {
						color = {
							output = {
								layout = color_attachment_optimal;
								blend = $alpha_blend;
							};
						};
					};
					pipelines = {
						output = {
							@inherit = $compose_base;

							color = $color.output;
							tasks = (
								{ func = output_draw_flat; },
							);

							stages = (
								$fstriangle.shader.vertex,
								$output.shader.fragment,
							);
							layout = $output.layout;
						};
						waterwarp = {
							@inherit = $compose_base;
							disabled = true;

							color = $color.output;
							tasks = (
								{ func = output_draw_waterwarp; },
							);

							stages = (
								$fstriangle.shader.vertexst,
								$waterwarp.shader.fragment,
							);
							layout = $waterwarp.layout;
						};
						fisheye = {
							@inherit = $compose_base;
							disabled = true;

							color = $color.output;
							tasks = (
								{ func = output_draw_fisheye; },
							);

							stages = (
								$fstriangle.shader.vertexst,
								$fisheye.shader.fragment,
							);
							layout = $fisheye.layout;
						};
						slice = {
							@inherit = $compose_base;

							color = $color.slice;
							tasks = (
								{ func = slice_draw; },
							);

							stages = (
								$slice.shader.vertex,
								$slice.shader.fragment,
							);
							vertexInput = $slice.vertexInput;
							inputAssembly = $slice.inputAssembly;
							layout = $slice.layout;
						};
						lines = {
							@inherit = $compose_base;

							color = $color.lines;
							tasks = (
								{ func = line_draw; },
							);

							stages = (
								$lines.shader.vertex,
								$lines.shader.fragment,
							);
							vertexInput = $lines.vertexInput;
							inputAssembly = $lines.inputAssembly;
							layout = $lines.layout;
						};
					};
				};
			};
		};
		shadow = {
			color = "[0.2, 0.2, 0.2, 1]";
			framebuffer = {
				layers = 1;
				attachments = {
					shadow = $shadow;
				};
			};
			subpasses = {
				shadow = {
					color = "[ 0.5,  0.5,  0.5, 1]";
					attachments = {
						depth = {
							shadow = depth_stencil_attachment_optimal;
						};
					};

					base_pipeline = {
						@inherit = $pipeline_base;
						depthStencil = $depth_test_and_write;
						rasterization = $cw_cull_front;
					};
					pipelines = {
						bsp:shadow = {
							color = $color.bsp;
							tasks = (
								{ func = bsp_draw_queue;
								  params = (shadow, solid, 0); },
							);

							stages = (
								$brush.shader.shadow_vertex,
							);
							vertexInput = {
								bindings = (
									"$brush.vertexInput.bindings[0]",
									"$brush.vertexInput.bindings[1]",
								);
								attributes = (
									"$brush.vertexInput.attributes[0]",
									"$brush.vertexInput.attributes[2]",
								);
							};
							inputAssembly = $brush.inputAssembly;
							layout = $brush.shadow_layout;
						};
						alias:shadow = {
							color = $color.alias;
							tasks = (
								{ func = alias_draw;
								  params = (shadow, 0); },
							);

							stages = (
								$alias.shader.shadow_vertex,
							);
							vertexInput = {
								// depth/shadow pass doesn't use UVs
								bindings = (
									"$alias.vertexInput.bindings[0]",
									"$alias.vertexInput.bindings[1]",
								);
								attributes = (
									"$alias.vertexInput.attributes[0]",
									"$alias.vertexInput.attributes[1]",
									"$alias.vertexInput.attributes[2]",
									"$alias.vertexInput.attributes[3]",
								);
							};
							inputAssembly = $alias.inputAssembly;
							layout = $alias.shadow_layout;
							dynamic = {
								dynamicState = (
									viewport,
									scissor,
									vertex_input_ext,
								);
							};
						};
					};
				};
				$external = {
					dependencies = {
						shadow = {
							src = {
								stage = late_fragment_tests;
								access = depth_stencil_attachment_write;
							};
							dst = {
								stage = transfer;
								access = transfer_read;
							};
						}
					};
				};
			};
		};
		shadow2 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x03u);
			});
		};
		shadow3 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x07u);
			});
		};
		shadow4 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x0fu);
			});
		};
		shadow5 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x1fu);
			});
		};
		shadow6 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3fu);
			});
		};
		shadow7 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x7fu);
			});
		};
		shadow8 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0xffu);
			});
		};
		shadow9 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x1ffu);
			});
		};
		shadow10 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3ffu);
			});
		};
		shadow11 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x7ffu);
			});
		};
		shadow12 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0xfffu);
			});
		};
		shadow13 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x1fffu);
			});
		};
		shadow14 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3fffu);
			});
		};
		shadow15 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x7fffu);
			});
		};
		shadow16 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0xffffu);
			});
		};
		shadow17 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x1ffffu);
			});
		};
		shadow18 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3ffffu);
			});
		};
		shadow19 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x7ffffu);
			});
		};
		shadow20 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0xfffffu);
			});
		};
		shadow21 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x1fffffu);
			});
		};
		shadow22 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3fffffu);
			});
		};
		shadow23 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x7fffffu);
			});
		};
		shadow24 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0xffffffu);
			});
		};
		shadow25 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x1ffffffu);
			});
		};
		shadow26 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3ffffffu);
			});
		};
		shadow27 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x7ffffffu);
			});
		};
		shadow28 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0xfffffffu);
			});
		};
		shadow29 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x1fffffffu);
			});
		};
		shadow30 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x3fffffffu);
			});
		};
		shadow31 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0x7fffffffu);
			});
		};
		shadow32 = {
			@inherit = $renderpasses.shadow;
			@next = (VkRenderPassMultiviewCreateInfo, {
				viewMasks   = (0xffffffffu);
			});
		};
	};
	steps = {
		wait_on_fence = {
			color = "[0.6, 0.8, 0.0]";
			process = {
				tasks = (
					{ func = wait_on_fence; },
					{ func = capture_finalize; },
					{ func = mousepick_finalize; },
					{ func = update_matrices; },
					{ func = draw_scr_funcs; },
				);
			};
		};
		particles = {
			color = "[0.6, 0.8, 0.9]";
			dependencies = (wait_on_fence);
			compute = {
				pipelines = {
					part:update = {
						color = "[0.3, 0.8, 0.9]";
						tasks = (
							{ func = update_particles; }
						);
						stage = {
							name = main;
							module = $builtin/partupdate.comp;
						};
						layout = $particle.layout.update;
					};
					part:physics = {
						color = "[0.6, 0.8, 0.9]";
						tasks = (
							{ func = particle_physics; }
						);
						stage = {
							name = main;
							module = $builtin/partphysics.comp;
						};
						layout = $particle.layout.physics;
					};
				};
			};
		};
		world = {
			color = "[0.3, 0.4, 0.0]";
			dependencies = (wait_on_fence);
			process = {
				tasks = (
					{ func = bsp_reset_queues; },
					{ func = bsp_visit_world;
					  params = (main); },
					{ func = scene_draw_viewmodel; },
					{ func = lighting_update_lights; },
				);
			};
		};
		light_cull = {
			color = "[0.8, 0.6, 0, 1]";
			dependencies = (world);
			process = {
				tasks = (
					{ func = lighting_cull_select_renderpass;
					  params = ("\"light_cull\""); },
					{ func = update_framebuffer;
					  params = ("\"light_cull\""); },
					{ func = lighting_cull_lights;
					  params = ("\"light_cull\""); },
				);
			};
			render = {
				renderpasses = {
					occlusion = $renderpasses.occlusion;
					occlusion_cube = $renderpasses.occlusion_cube;
				};
			};
		};
		shadow = {
			color = "[0.3, 0.3, 0.3]";
			dependencies = (light_cull);
			process = {
				tasks = (
					{ func = lighting_setup_shadow; },
					{ func = bsp_visit_world;
					  params = (shadow); },
					{ func = lighting_draw_shadow_maps;
					  params = ("\"shadow\""); },
				);
			};
			render = {
				renderpasses = {
					shadow = $renderpasses.shadow;
					shadow2 = $renderpasses.shadow2;
					shadow3 = $renderpasses.shadow3;
					shadow4 = $renderpasses.shadow4;
					shadow5 = $renderpasses.shadow5;
					shadow6 = $renderpasses.shadow6;
	/* FIXME dynamic limit
					shadow7 = $renderpasses.shadow7;
					shadow8 = $renderpasses.shadow8;
					shadow9 = $renderpasses.shadow9;
					shadow10 = $renderpasses.shadow10;
					shadow11 = $renderpasses.shadow11;
					shadow12 = $renderpasses.shadow12;
					shadow13 = $renderpasses.shadow13;
					shadow14 = $renderpasses.shadow14;
					shadow15 = $renderpasses.shadow15;
					shadow16 = $renderpasses.shadow16;
					shadow17 = $renderpasses.shadow17;
					shadow18 = $renderpasses.shadow18;
					shadow19 = $renderpasses.shadow19;
					shadow20 = $renderpasses.shadow20;
					shadow21 = $renderpasses.shadow21;
					shadow22 = $renderpasses.shadow22;
					shadow23 = $renderpasses.shadow23;
					shadow24 = $renderpasses.shadow24;
					shadow25 = $renderpasses.shadow25;
					shadow26 = $renderpasses.shadow26;
					shadow27 = $renderpasses.shadow27;
					shadow28 = $renderpasses.shadow28;
					shadow29 = $renderpasses.shadow29;
					shadow30 = $renderpasses.shadow30;
					shadow31 = $renderpasses.shadow31;
					shadow32 = $renderpasses.shadow32;
	*/
				};
			};
		};
		setup_main = {
			color = "[0.3, 0.8, 0.3]";
			dependencies = (wait_on_fence);
			process = {
				tasks = (
					{ func = output_select_renderpass;
					  params = ("\"main\""); },
					{ func = update_framebuffer;
					  params = ("\"main\""); },
					{ func = clear_translucent;
					  params = ("\"main\""); },
					{ func = particle_wait_physics; },
					{ func = lighting_update_descriptors;
					  params = ("\"main\""); },
				);
			};
		};
		main = {
			color = "[0.3, 0.8, 0.0]";
			dependencies = (setup_main, particles, shadow, world);
			render = {
				renderpasses = {
					deferred = $renderpasses.deferred;
					deferred_cube = $renderpasses.deferred_cube;
				};
			};
		};
		preoutput = {
			color = "[0.8, 0.8, 0.0]";
			dependencies = (wait_on_fence);
			process = {
				tasks = (
					{ func = acquire_output;
					  params = ("\"output\""); },
					{ func = update_input;
					  params = ("\"main\""); },
					{ func = output_select_pipeline;
					  params = ("\"output\""); },
					{ func = flush_draw; },
				);
			};
		};
		output = {
			color = "[0.4, 0.8, 0.4]";
			dependencies = (main, preoutput);
			render = {
				renderpasses = {
					output = $renderpasses.output;
				};
			};
		};
		capture = {
			color = "[0.0, 0.8, 0.4]";
			dependencies = (output);
			process = {
				tasks = (
					{ func = capture_initiate; },
				);
			};
		};
		mouse_pick = {
			color = "[0.0, 0.0, 0.8]";
			dependencies = (main);
			process = {
				tasks = (
					{ func = mousepick_initiate; },
				);
			};
		};
	};
	newscene_tasks = (
		{ func = bsp_register_textures; },
		{ func = bsp_build_display_lists; },
		{ func = lighting_load_lights; },
	);
	init_tasks = (
		{ func = texture_init; },
		{ func = palette_init; },
		{ func = alias_init; },
		{ func = bsp_init; },
		{ func = matrices_init; },
		{ func = scene_init; },
		{ func = sprite_init; },
		{ func = output_init; },
		{ func = compose_init; },
		{ func = draw_init; },
		{ func = particle_init; },
		{ func = planes_init; },
		{ func = planes_set_size; params = (1); },
		{ func = translucent_init; },
		{ func = lighting_init; },
	);
};
}
