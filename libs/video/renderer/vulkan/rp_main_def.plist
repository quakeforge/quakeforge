properties = {
	color = {
		bsp       = "[0.0, 0.5, 0.6, 1]";
		alias     = "[0.6, 0.5, 0.0, 1]";
		iqm       = "[0.6, 0.5, 0.0, 1]";
		sprite    = "[0.6, 0.5, 0.0, 1]";
		particles = "[0.4, 0.5, 0.8, 1]";
		lights    = "[0.8, 0.6, 0.2, 1]";
		compose   = "[0.7, 0.7, 0.7, 1]";

		output    = "[0.0, 0.7, 0.7, 1]";
		waterwarp = "[0.0, 0.7, 0.7, 1]";
		fisheye   = "[0.0, 0.7, 0.7, 1]";
		slice     = "[0.8, 0.7, 0.2, 1]";
		lines     = "[0.8, 0.7, 0.4, 1]";
	};
	color_dependency = {
		src = {
			stage = color_attachment_output;
			access = color_attachment_write;
		};
		dst = {
			stage = fragment_shader;
			access = input_attachment_read;
		};
		flags = by_region;
	};
	depth_dependency = {
		src = {
			stage = late_fragment_tests;
			access = depth_stencil_attachment_write;
		};
		dst = {
			stage = fragment_shader|early_fragment_tests;
			access = input_attachment_read|depth_stencil_attachment_read;
		};
		flags = by_region;
	};
	image_base = {
		imageType = `2d;
		samples = 1;
		extent = {
			width = $render_output.extent.width;
			height = $render_output.extent.height;
			depth = 1;
		};
		mipLevels = 1;
		arrayLayers = 1;
		tiling = optimal;
		usage = color_attachment|input_attachment|transient_attachment;
		initialLayout = undefined;
	};
	cube_image_base = {
		@inherit = $image_base;
		extent = {
			width = "min($render_output.extent.width,$render_output.extent.height)";
			height = "min($render_output.extent.width,$render_output.extent.height)";
			depth = 1;
		};
		arrayLayers = 6;
	};
	view_base = {
		viewType = `2d;
		components = {
			r = identity;
			g = identity;
			b = identity;
			a = identity;
		};
		subresourceRange = {
			aspectMask = color;
			levelCount = 1;
			layerCount = 1;
		};
	};
	cube_view_base = {
		@inherit = $view_base;
		viewType = `2d_array;
		subresourceRange = {
			layerCount = 6;
		};
	};
	attachment_base = {
		samples = 1;
		loadOp = dont_care;
		storeOp = dont_care;
		stencilLoadOp = dont_care;
		stencilStoreOp = dont_care;
		initialLayout = undefined;
		finalLayout = color_attachment_optimal;
		clearValue = { color = "[0, 0, 0, 1]"; };
	};

	no_cull = {
		depthClampEnable = false;
		rasterizerDiscardEnable = false;
		polygonMode = fill;
		cullMode = none;
		frontFace = counter_clockwise;
		depthBiasEnable = false;
		lineWidth = 1;
	};
	debug_poly_lines = {
		depthClampEnable = false;
		rasterizerDiscardEnable = false;
		polygonMode = line;
		cullMode = none;
		frontFace = clockwise;
		depthBiasEnable = false;
		lineWidth = 1;
	};
	cw_cull_back = {
		depthClampEnable = false;
		rasterizerDiscardEnable = false;
		polygonMode = fill;
		cullMode = back;
		frontFace = clockwise;
		depthBiasEnable = false;
		lineWidth = 1;
	};
	cw_cull_front = {
		depthClampEnable = false;
		rasterizerDiscardEnable = false;
		polygonMode = fill;
		cullMode = front;
		frontFace = clockwise;
		depthBiasEnable = false;
		lineWidth = 1;
	};
	counter_cw_cull_back = {
		depthClampEnable = false;
		rasterizerDiscardEnable = false;
		polygonMode = fill;
		cullMode = back;
		frontFace = counter_clockwise;
		depthBiasEnable = false;
		lineWidth = 1;
	};
	depth_test_and_write = {
		depthTestEnable = true;
		depthWriteEnable = true;
		depthCompareOp = greater_or_equal;
		depthBoundsTestEnable = false;
		stencilTestEnable = false;
	};
	depth_test_only = {
		depthTestEnable = true;
		depthWriteEnable = false;
		depthCompareOp = greater_or_equal;
		depthBoundsTestEnable = false;
		stencilTestEnable = false;
	};
	depth_test_only_reverse = {
		depthTestEnable = true;
		depthWriteEnable = false;
		depthCompareOp = greater;
		depthBoundsTestEnable = false;
		stencilTestEnable = false;
	};
	depth_disable = {
		depthTestEnable = false;
		depthWriteEnable = false;
		depthCompareOp = greater_or_equal;
		depthBoundsTestEnable = false;
		stencilTestEnable = false;
	};
	blend_disable = {
		blendEnable = false;
		srcColorBlendFactor = src_alpha;
		dstColorBlendFactor = one_minus_src_alpha;
		colorBlendOp = add;
		srcAlphaBlendFactor = src_alpha;
		dstAlphaBlendFactor = one_minus_src_alpha;
		alphaBlendOp = add;
		colorWriteMask = r|g|b|a;
	};
	alpha_blend = {
		blendEnable = true;
		srcColorBlendFactor = one;
		dstColorBlendFactor = one_minus_src_alpha;
		colorBlendOp = add;
		srcAlphaBlendFactor = one;
		dstAlphaBlendFactor = one_minus_src_alpha;
		alphaBlendOp = add;
		colorWriteMask = r|g|b|a;
	};
	additive_blend = {
		blendEnable = true;
		srcColorBlendFactor = one;
		dstColorBlendFactor = one;
		colorBlendOp = add;
		srcAlphaBlendFactor = zero;
		dstAlphaBlendFactor = one;
		alphaBlendOp = add;
		colorWriteMask = r|g|b|a;
	};
	pipeline_base = {
		viewport = {
			viewports = (
				{
					x = 0; y = 0;
					width = 640; height = 480;
					minDepth = 0; maxDepth = 1;
				}
			);
			scissors = (
				{
					offset = { x = 0; y = 0; };
					extent = { width = 640; height = 480; };
				},
			);
		};
		rasterization = $cw_cull_back;
		multisample = {
			rasterizationSamples = $msaaSamples;
			sampleShadingEnable = false;
			minSampleShading = 0.5f;
			alphaToCoverageEnable = false;
			alphaToOneEnable = false;
		};
		depthStencil = $depth_test_only;
		colorBlend = {
			logicOpEnable = false;
		};
		dynamic = {
			dynamicState = ( viewport, scissor );
		};
	};
	compose_base = {
		@inherit = $pipeline_base;
		rasterization = $counter_cw_cull_back;
		vertexInput = {
			bindings = ();
			attributes = ();
		};
		inputAssembly = {
			topology = triangle_list;
			primitiveRestartEnable = false;
		};
	};

	brush = {
		shader = {
			shadow_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/bsp_shadow.vert;
			};
			depth_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/bsp_depth.vert;
			};
			debug_fragment = {
				stage = fragment;
				name = main;
				module = $builtin/debug.frag;
			};
			gbuf_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/bsp_gbuf.vert;
			};
			gbuf_geometry = {
				stage = geometry;
				name = main;
				module = $builtin/bsp_gbuf.geom;
			};
			gbuf_fragment = {
				stage = fragment;
				name = main;
				module = $builtin/bsp_gbuf.frag;
			};
			quake_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/quakebsp.vert;
			};
			sky_specialization = {
				mapEntries = (
					// doSkyBox
					{ size = 4; offset = 0; constantID = 0; },
					// doSkySheet
					{ size = 4; offset = 4; constantID = 1; },
				);
			};
			skybox_fragment = {
				stage = fragment;
				name = main;
				module = $builtin/bsp_sky.frag;
				specializationInfo = {
					@inherit = $brush.shader.sky_specialization;
					// doSkyBox, doSkySheet
					data = "array(1, 0)";
				};
			};
			skysheet_fragment = {
				stage = fragment;
				name = main;
				module = $builtin/bsp_sky.frag;
				specializationInfo = {
					@inherit = $brush.shader.sky_specialization;
					// doSkyBox, doSkySheet
					data = "array(0, 1)";
				};
			};
			turb_fragment = {
				stage = fragment;
				name = main;
				module = $builtin/bsp_turb.frag;
			};
		};
		vertexInput = {
			bindings = (
				{ binding = 0; stride = "2 * 4 * 4"; inputRate = vertex; },
				{ binding = 1; stride = "4"; inputRate = instance; },
			);
			attributes = (
				{ location = 0; binding = 0; format = r32g32b32a32_sfloat; offset = 0;  },
				{ location = 1; binding = 0; format = r32g32b32a32_sfloat; offset = 16; },
				{ location = 2; binding = 1; format = r32_uint; offset = 0; },
			);
		};
		inputAssembly = {
			topology = triangle_fan;
			primitiveRestartEnable = true;
		};
		layout = {
			descriptorSets = (matrix_set, entity_set, oit_set,
			//				  surface      skybox
							  texture_set, texture_set);
			pushConstants = {
				fragment = {
					fog = vec4;
					time = float;
					alpha = float;
					turb_scale = float;
				};
			};
		};
		shadow_layout = {
			descriptorSets = (shadowmat_set, entity_set);
			pushConstants = {
				vertex = {
					MatrixBase = uint;
				};
			};
		};
	};
	alias = {
		shader = {
			shadow_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/alias_shadow.vert;
			};
			depth_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/alias_depth.vert;
			};
			gbuf_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/alias.vert;
			};
		};
		vertexInput = {
			bindings = (
				{ binding = 0; stride = "2 * 4 * 4"; inputRate = vertex; },
				{ binding = 1; stride = "2 * 4 * 4"; inputRate = vertex; },
				{ binding = 2; stride = "2 * 4"; inputRate = vertex; },
			);
			attributes = (
				{ location = 0; binding = 0; format = r32g32b32a32_sfloat; offset = 0;  },
				{ location = 1; binding = 0; format = r32g32b32a32_sfloat; offset = 16; },
				{ location = 2; binding = 1; format = r32g32b32a32_sfloat; offset = 0;  },
				{ location = 3; binding = 1; format = r32g32b32a32_sfloat; offset = 16; },
				{ location = 4; binding = 2; format = r32g32_sfloat; offset = 0; },
			);
		};
		inputAssembly = {
			topology = triangle_list;
			primitiveRestartEnable = false;
		};
		layout = {
			//                            palette      skin
			descriptorSets = (matrix_set, texture_set, texture_set);
			pushConstants = {
				vertex   = { Model = mat4; blend = float; };
				fragment = { colors = uint; base_color = vec4; fog = vec4; };
			};
		};
		shadow_layout = {
			descriptorSets = (shadowmat_set);
			pushConstants = {
				vertex = { Model = mat4; blend = float; MatrixBase = uint; };
			};
		};
	};
	qskin = {
		shader = {
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/qskin_gbuf.frag;
			};
		};
	};
	iqm = {
		shader = {
			specialization = {
				mapEntries = (
					// IQMDepthOnly
					{ size = 4; offset = 0; constantID = 0; },
				);
			};
			shadow_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/iqm_shadow.vert;
				specializationInfo = {
					@inherit = $iqm.shader.specialization;
					// IQMDepthOnly
					data = "array(1)";
				};
			};
			depth_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/iqm.vert;
				specializationInfo = {
					@inherit = $iqm.shader.specialization;
					// IQMDepthOnly
					data = "array(1)";
				};
			};
			gbuf_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/iqm.vert;
				specializationInfo = {
					@inherit = $iqm.shader.specialization;
					// IQMDepthOnly
					data = "array(0)";
				};
			};
		};
		vertexInput = {
			bindings = (
				{ binding = 0; stride = 20; inputRate = vertex; },
				{ binding = 1; stride = 40; inputRate = vertex; },
			);
			attributes = (
				{ location = 0; binding = 0; format = r32g32b32_sfloat;    offset = 0;  },	// position
				{ location = 1; binding = 0; format = r8g8b8a8_uint;       offset = 12; },	// bonindices
				{ location = 2; binding = 0; format = r8g8b8a8_unorm;      offset = 16; },	// boneweights

				{ location = 3; binding = 1; format = r32g32_sfloat;       offset = 0;  },	// texcoord
				{ location = 4; binding = 1; format = r32g32b32_sfloat;    offset = 8;  },	// normal
				{ location = 5; binding = 1; format = r32g32b32a32_sfloat; offset = 20; },	// tangent
				{ location = 6; binding = 1; format = r8g8b8a8_unorm;      offset = 36; },	// color

			);
		};
		inputAssembly = {
			topology = triangle_list;
			primitiveRestartEnable = false;
		};
		layout = {
			//                            palette      skin
			descriptorSets = (matrix_set, texture_set, texture_set, bone_set);
			pushConstants = {
				vertex   = { Model = mat4; blend = float; };
				fragment = { colors = uint; base_color = vec4; fog = vec4; };
			};
		};
		shadow_layout = {
			//                               palette(n/u) skin(n/u)
			descriptorSets = (shadowmat_set, texture_set, texture_set, bone_set);
			pushConstants = {
				vertex   = { Model = mat4; blend = float; MatrixBase = uint; };
			};
		};
	};
	sprite = {
		shader = {
			depth_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/sprite_depth.vert;
			};
			depth_fragment = {
				stage = fragment;
				name = main;
				module = $builtin/sprite_depth.frag;
			};
			gbuf_vertex = {
				stage = vertex;
				name = main;
				module = $builtin/sprite_gbuf.vert;
			};
			gbuf_fragment = {
				stage = fragment;
				name = main;
				module = $builtin/sprite_gbuf.frag;
			};
		};
		vertexInput = {
			bindings = ();
			attributes = ();
		};
		inputAssembly = {
			topology = triangle_strip;
			// never draw more than 4 verts
			primitiveRestartEnable = false;
		};
		layout = {
			descriptorSets = (matrix_set, sprite_set);
			pushConstants = {
				vertex   = {
					Model = mat4;
					frame = int;
				};
				fragment = {
					overlap   = { offset = 64; type = int; };
					frame     = int;
					spriteind = int;
					fog       = vec4;
				};
			};
		};
	};
	particle = {
		shader = {
			vertex = {
				stage = vertex;
				name = main;
				module = $builtin/particle.vert;
			};
			geometry = {
				stage = geometry;
				name = main;
				module = $builtin/particle.geom;
			};
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/particle.frag;
			};
		};
		vertexInput = {
			bindings = (
				{ binding = 0; stride = "4 * 4 * 4"; inputRate = instance; },
			);
			attributes = (
				{ location = 0; binding = 0; format = r32g32b32a32_sfloat; offset = 0;  },
				{ location = 1; binding = 0; format = r32g32b32a32_sfloat; offset = 16; },
				{ location = 2; binding = 0; format = r32g32b32a32_sfloat; offset = 32; },
				{ location = 3; binding = 0; format = r32g32b32a32_sfloat; offset = 48; },
			);
		};
		inputAssembly = {
			topology = point_list;
			primitiveRestartEnable = false;
		};
		layout = {
			draw = {
				//                            palette
				descriptorSets = (matrix_set, texture_set, oit_set);
				pushConstants = {
					vertex = { Model = mat4; };
					fragment = { fog = vec4; };
				};
			};
			physics = {
				descriptorSets = (particle_set);
				pushConstants = {
					compute = { gravity = vec4; dT = float; };
				};
			};
			update = {
				//                cur           in            new
				descriptorSets = (particle_set, particle_set, particle_set);
			};
		};
	};
	fstriangle = {
		shader = {
			vertex = {
				stage = vertex;
				name = main;
				module = $builtin/fstriangle.vert;
			};
			vertexst = {
				stage = vertex;
				name = main;
				module = $builtin/fstrianglest.vert;
			};
		};
	};
	gridplane = {
		shader = {
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/gridplane.frag;
			};
		};
		layout = {
			descriptorSets = (matrix_set, planes_set);
		};
	};
	general = {
		shader = {
			fragment_entid = {
				stage = fragment;
				name = main;
				module = $builtin/entid.frag;
			};
		};
	};
	lighting = {
		shader = {
			vertex_splat = {
				stage = vertex;
				name = main;
				module = $builtin/light_splat.vert;
			};
			vertex_entid = {
				stage = vertex;
				name = main;
				module = $builtin/light_entid.vert;
			};
			vertex_flat = {
				stage = vertex;
				name = main;
				module = $builtin/light_flat.vert;
			};
			fragment_splat = {
				stage = fragment;
				name = main;
				module = $builtin/light_splat.frag;
			};
			fragment_none = {
				stage = fragment;
				name = main;
				module = $builtin/lighting_none.frag;
			};
			fragment_plane = {
				stage = fragment;
				name = main;
				module = $builtin/lighting_plane.frag;
			};
			fragment_cascade = {
				stage = fragment;
				name = main;
				module = $builtin/lighting_cascade.frag;
			};
			fragment_cube = {
				stage = fragment;
				name = main;
				module = $builtin/lighting_cube.frag;
			};
			debug_fragment = {
				stage = fragment;
				name = main;
				module = $builtin/light_debug.frag;
			};
			debug_oit = {
				stage = fragment;
				name = main;
				module = $builtin/light_oit.frag;
			};
		};
		vertexInput_splat = {
			bindings = (
				{ binding = 0; stride = "4"; inputRate = instance; },
				{ binding = 1; stride = "4"; inputRate = instance; },
				{ binding = 2; stride = "3 * 4"; inputRate = vertex; },
			);
			attributes = (
				{ location = 0; binding = 0; format = r32_uint; offset = 0; },
				{ location = 1; binding = 1; format = r32_sfloat; offset = 0; },
				{ location = 2; binding = 2; format = r32g32b32_sfloat; offset = 0;  },
			);
		};
		vertexInput_flat = {
			bindings = (
				{ binding = 0; stride = "4"; inputRate = instance; },
			);
			attributes = (
				{ location = 0; binding = 0; format = r32_uint; offset = 0; },
			);
		};
		inputAssembly = {
			topology = triangle_fan;
			primitiveRestartEnable = true;
		};
		splat_layout = {
			descriptorSets = (matrix_set, lighting_lights);
		};
		splat_oit_layout = {
			descriptorSets = (matrix_set, lighting_lights, oit_set);
		};
		layout = {
			descriptorSets = (shadowmat_set, lighting_lights,
							  lighting_attach, lighting_shadow);
			pushConstants = {
				fragment = {
					CascadeDepths = vec4;
					queue = uint;
				};
			};
		};
	};
	compose = {
		shader = {
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/compose.frag;
			};
		};
		layout = {
			descriptorSets = (compose_attach, oit_set);
		};
	};
	output = {
		@inherit = $compose_base;
		shader = {
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/output.frag;
			};
		};
		layout = {
			descriptorSets = (matrix_set, output_set);
		};
	};
	waterwarp = {
		@inherit = $compose_base;
		shader = {
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/waterwarp.frag;
			};
		};
		layout = {
			descriptorSets = (matrix_set, output_set);
			pushConstants = {
				fragment = { time = float; };
			};
		};
	};
	fisheye = {
		@inherit = $compose_base;
		shader = {
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/fisheye.frag;
			};
		};
		layout = {
			descriptorSets = (matrix_set, output_set);
			pushConstants = {
				fragment = { fov = float; aspect = float; };
			};
		};
	};
	slice = {
		shader = {
			vertex = {
				stage = vertex;
				name = main;
				module = $builtin/slice.vert;
			};
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/twod.frag;
			};
		};
		vertexInput = {
			bindings = (
				{ binding = 0; stride = "4 + 4 + 4*4"; inputRate = instance; },
			);
			attributes = (
				// 9-slice index
				{ location = 0; binding = 0; format = r32_uint;       offset = 0; },
				// 9-slice color
				{ location = 1; binding = 0; format = r8g8b8a8_unorm; offset = 4; },
				// 9-slice position (2d)
				{ location = 2; binding = 0; format = r32g32_sfloat;  offset = 8; },
				// 9-slice size delta (2d)
				{ location = 3; binding = 0; format = r32g32_sfloat;  offset = 16; },
			);
		};
		inputAssembly = {
			topology = triangle_strip;
			primitiveRestartEnable = true;
		};
		layout = {
			descriptorSets = (matrix_set, quad_data_set);
		};
	};
	lines = {
		shader = {
			vertex = {
				stage = vertex;
				name = main;
				module = $builtin/line.vert;
			};
			fragment = {
				stage = fragment;
				name = main;
				module = $builtin/line.frag;
			};
		};
		vertexInput = {
			bindings = (
				{ binding = 0; stride = "2 * 4 + 4"; inputRate = vertex; },
			);
			attributes = (
				{ location = 0; binding = 0; format = r32g32_sfloat;  offset = 0; },
				{ location = 1; binding = 0; format = r8g8b8a8_unorm; offset = 8; },
			);
		};
		inputAssembly = {
			topology = line_list;
			primitiveRestartEnable = false;
		};
		layout = {
			descriptorSets = (matrix_set);
		};
	};
};
descriptorSetLayouts = {
	matrix_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = uniform_buffer;
				descriptorCount = 1;
				stageFlags = vertex|geometry|fragment;
			},
		);
	};
	shadowmat_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = vertex|fragment;
			},
			{
				binding = 1;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = vertex;
			},
		);
	};
	quad_data_set = {
		bindings = (
			{
				// glyph texture data
				binding = 0;
				descriptorType = combined_image_sampler;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				// glyph geometry data (offset and uv)
				binding = 1;
				descriptorType = uniform_texel_buffer;
				descriptorCount = 1;
				stageFlags = vertex;
			},
		);
	};
	texture_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = combined_image_sampler;
				descriptorCount = 1;
				stageFlags = fragment|vertex;
			},
		);
	};
	oit_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 1;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 2;
				descriptorType = storage_image;
				descriptorCount = 1;
				stageFlags = fragment;
			},
		);
	};
	entity_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = vertex;
			},
		);
	};
	bone_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = vertex;
			},
		);
	};
	planes_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = fragment;
			},
		);
	};
	sprite_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = uniform_buffer;
				descriptorCount = 1;
				stageFlags = vertex;
			},
			{
				binding = 1;
				descriptorType = combined_image_sampler;
				descriptorCount = 1;
				stageFlags = fragment;
			},
		);
	};
	lighting_attach = {
		bindings = (
			{
				binding = 0;
				descriptorType = input_attachment;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 1;
				descriptorType = input_attachment;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 2;
				descriptorType = input_attachment;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 3;
				descriptorType = input_attachment;
				descriptorCount = 1;
				stageFlags = fragment;
			},
		);
	};
	lighting_lights = {
		bindings = (
			{
				binding = 0;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = vertex|fragment;
			},
			{
				binding = 1;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = vertex|fragment;
			},
			{
				binding = 2;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 3;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 4;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = vertex;
			},
		);
	};
	lighting_shadow = {
		bindings = (
			{
				binding = 0;
				descriptorType = combined_image_sampler;
				descriptorCount = 32;
				stageFlags = fragment;
			},
		);
	};
	compose_attach = {
		bindings = (
			{
				binding = 0;
				descriptorType = input_attachment;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 1;
				descriptorType = input_attachment;
				descriptorCount = 1;
				stageFlags = fragment;
			},
			{
				binding = 2;
				descriptorType = input_attachment;
				descriptorCount = 1;
				stageFlags = fragment;
			},
		);
	};
	particle_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = compute;
			},
			{
				binding = 1;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = compute;
			},
			{
				binding = 2;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = compute;
			},
		);
	};
	particle_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = compute;
			},
			{
				binding = 1;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = compute;
			},
			{
				binding = 2;
				descriptorType = storage_buffer;
				descriptorCount = 1;
				stageFlags = compute;
			},
		);
	};
	output_set = {
		bindings = (
			{
				binding = 0;
				descriptorType = combined_image_sampler;
				descriptorCount = 1;
				stageFlags = fragment;
			},
		);
	};
};
images = {
	occlusion_depth = {
		@inherit = $image_base;
		format = d32_sfloat;
		usage = depth_stencil_attachment|input_attachment|transient_attachment;
	};
	depth = {
		@inherit = $image_base;
		format = d32_sfloat;
		usage = depth_stencil_attachment|input_attachment|transient_attachment;
	};
	color = {
		@inherit = $image_base;
		format = r8g8b8a8_unorm;
	};
	emission = {
		@inherit = $image_base;
		format = r16g16b16a16_sfloat;
	};
	normal = {
		@inherit = $image_base;
		format = r16g16b16a16_sfloat;
	};
	position = {
		@inherit = $image_base;
		format = r32g32b32a32_sfloat;
	};
	light = {
		@inherit = $image_base;
		format = r16g16b16a16_sfloat;
	};
	output = {
		@inherit = $image_base;
		usage = color_attachment|input_attachment|sampled;
		format = $render_output.format;
	};
	entid = {
		@inherit = $image_base;
		usage = color_attachment|transfer_src;
		format = r32_uint;
	};

	occlusion_cube_depth = {
		@inherit = $cube_image_base;
		format = d32_sfloat;
		usage = depth_stencil_attachment|input_attachment|transient_attachment;
	};
	cube_depth = {
		@inherit = $cube_image_base;
		format = d32_sfloat;
		usage = depth_stencil_attachment|input_attachment|transient_attachment;
	};
	cube_color = {
		@inherit = $cube_image_base;
		format = r8g8b8a8_unorm;
	};
	cube_emission = {
		@inherit = $cube_image_base;
		format = r16g16b16a16_sfloat;
	};
	cube_normal = {
		@inherit = $cube_image_base;
		format = r16g16b16a16_sfloat;
	};
	cube_position = {
		@inherit = $cube_image_base;
		format = r32g32b32a32_sfloat;
	};
	cube_light = {
		@inherit = $cube_image_base;
		format = r16g16b16a16_sfloat;
	};
	cube_output = {
		@inherit = $cube_image_base;
		flags = cube_compatible;
		usage = color_attachment|input_attachment|sampled;
		format = $render_output.format;
	};
	cube_entid = {
		@inherit = $cube_image_base;
		usage = color_attachment|transfer_src;
		format = r32_uint;
	};
};
imageviews = {
	occlusion_depth = {
		@inherit = $view_base;
		image = occlusion_depth;
		format = $images.occlusion_depth.format;
		subresourceRange = {
			aspectMask = depth;
		};
	};
	depth = {
		@inherit = $view_base;
		image = depth;
		format = $images.depth.format;
		subresourceRange = {
			aspectMask = depth;
		};
	};
	color = {
		@inherit = $view_base;
		image = color;
		format = $images.color.format;
	};
	emission = {
		@inherit = $view_base;
		image = emission;
		format = $images.emission.format;
	};
	normal = {
		@inherit = $view_base;
		image = normal;
		format = $images.normal.format;
	};
	position = {
		@inherit = $view_base;
		image = position;
		format = $images.position.format;
	};
	light = {
		@inherit = $view_base;
		image = light;
		format = $images.light.format;
	};
	output = {
		@inherit = $view_base;
		image = output;
		format = $render_output.format;
	};
	entid = {
		@inherit = $view_base;
		image = entid;
	};
	occlusion_cube_depth = {
		@inherit = $cube_view_base;
		image = occlusion_cube_depth;
		format = $images.occlusion_cube_depth.format;
		subresourceRange = {
			aspectMask = depth;
		};
	};
	cube_depth = {
		@inherit = $cube_view_base;
		image = cube_depth;
		format = $images.cube_depth.format;
		subresourceRange = {
			aspectMask = depth;
		};
	};
	cube_color = {
		@inherit = $cube_view_base;
		image = cube_color;
		format = $images.cube_color.format;
	};
	cube_emission = {
		@inherit = $cube_view_base;
		image = cube_emission;
		format = $images.cube_emission.format;
	};
	cube_normal = {
		@inherit = $cube_view_base;
		image = cube_normal;
		format = $images.cube_normal.format;
	};
	cube_position = {
		@inherit = $cube_view_base;
		image = cube_position;
		format = $images.cube_position.format;
	};
	cube_light = {
		@inherit = $cube_view_base;
		image = cube_light;
		format = $images.cube_light.format;
	};
	cube_output = {
		@inherit = $cube_view_base;
		viewType = cube;
		image = cube_output;
		format = $render_output.format;
	};
	cube_entid = {
		@inherit = $cube_view_base;
		image = cube_entid;
	};
};
output = {
	view = $output;
	format = r16g16b16a16_sfloat;
	finalLayout = shader_read_only_optimal;
};
renderpasses = {
	occlusion = {
		color = "[0.8, 0.6, 0, 1]";
		framebuffer = {
			width = $render_output.extent.width;
			height = $render_output.extent.height;
			layers = 1;
			attachments = {
				depth = {
					@inherit = $attachment_base;
					format = $images.depth.format;
					loadOp = clear;
					finalLayout = depth_stencil_attachment_optimal;
					clearValue = { depthStencil = { depth = 0; stencil = 0; }; };
					view = occlusion_depth;
				};
			};
		};
		subpasses = {
			depth = {
				color = "[ 0.5,  0.5,  0.5, 1]";
				attachments = {
					depth = {
						depth = depth_stencil_attachment_optimal;
					};
				};

				base_pipeline = {
					@inherit = $pipeline_base;
					depthStencil = $depth_test_and_write;
					rasterization = $cw_cull_back;
				};
				pipelines = {
					bsp:depth = {
						color = $color.bsp;
						tasks = (
							{ func = bsp_draw_queue;
							  params = (main, solid, 0); },
							{ func = bsp_draw_queue;
							  params = (main, sky, 0); },
						);

						stages = (
							$brush.shader.depth_vertex,
						);
						vertexInput = {
							bindings = (
								"$brush.vertexInput.bindings[0]",
								"$brush.vertexInput.bindings[1]",
							);
							attributes = (
								"$brush.vertexInput.attributes[0]",
								"$brush.vertexInput.attributes[2]",
							);
						};
						inputAssembly = $brush.inputAssembly;
						layout = $brush.layout;
					};
				};
			};
			lightcull = {
				color = "[ 0.7,  0.5,  0, 1]";
				dependencies = {
					depth = $depth_dependency;
				};
				attachments = {
					depth = {
						depth = depth_stencil_attachment_optimal;
					};
				};

				base_pipeline = {
					@inherit = $pipeline_base;
					depthStencil = $depth_test_only;
					rasterization = $cw_cull_back;
				};
				pipelines = {
					cull_lights = {
						@inherit = $compose_base;

						color = $color.lights;
						tasks = (
							{ func = lighting_bind_descriptors;
							  params = (hull, none); },
							{ func = lighting_draw_hulls; },
						);

						stages = (
							$lighting.shader.vertex_splat,
						);
						vertexInput = $lighting.vertexInput_splat;
						inputAssembly = $lighting.inputAssembly;
						layout = $lighting.splat_layout;
						rasterization = $counter_cw_cull_back;
						depthStencil = $depth_test_only;
					};
				};
			};
		};
	};
	occlusion_cube = {
		@inherit = $renderpasses.occlusion;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3fu, 0x3fu);
		});
		framebuffer = {
			width = "min($render_output.extent.width,$render_output.extent.height)";
			height = "min($render_output.extent.width,$render_output.extent.height)";
			layers = 1;
			attachments = {
				depth = {
					@inherit = $attachment_base;
					format = $images.cube_depth.format;
					loadOp = clear;
					finalLayout = depth_stencil_attachment_optimal;
					clearValue = { depthStencil = { depth = 0; stencil = 0; }; };
					view = occlusion_cube_depth;
				};
			};
		};
	};
	deferred = {
		color = "[0, 1, 0, 1]";
		framebuffer = {
			width = $render_output.extent.width;
			height = $render_output.extent.height;
			layers = 1;
			attachments = {
				depth = {
					@inherit = $attachment_base;
					format = $images.depth.format;
					loadOp = clear;
					finalLayout = depth_stencil_attachment_optimal;
					clearValue = { depthStencil = { depth = 0; stencil = 0; }; };
					view = depth;
				};
				color = {
					@inherit = $attachment_base;
					format = $images.color.format;
					loadOp = clear;
					view = color;
				};
				emission = {
					@inherit = $attachment_base;
					format = $images.emission.format;
					loadOp = clear;
					view = emission;
				};
				normal = {
					@inherit = $attachment_base;
					format = $images.normal.format;
					view = normal;
				};
				position = {
					@inherit = $attachment_base;
					format = $images.position.format;
					view = position;
				};
				light = {
					@inherit = $attachment_base;
					format = $images.light.format;
					loadOp = clear;
					view = light;
				};
				entid = {
					@inherit = $attachment_base;
					format = $images.entid.format;
					loadOp = clear;
					storeOp = store;
					finalLayout = transfer_src_optimal;
					clearValue = {
						color = { int32 = ( -1, -1, -1, -1); };
					};
					view = entid;
				};
				output = {
					@inherit = $attachment_base;
					format = $render_output.format;
					loadOp = clear;
					storeOp = store;
					finalLayout = $render_output.finalLayout;
					view = output;
				};
			};
		};
		subpasses = {
			depth = {
				color = "[ 0.5,  0.5,  0.5, 1]";
				attachments = {
					depth = {
						depth = depth_stencil_attachment_optimal;
					};
					preserve = (color, emission, normal, position, output);
				};

				base_pipeline = {
					@inherit = $pipeline_base;
					depthStencil = $depth_test_and_write;
					rasterization = $cw_cull_back;
				};
				pipelines = {
					bsp:depth = {
						color = $color.bsp;
						tasks = (
							{ func = bsp_draw_queue;
							  params = (main, solid, 0); },
							{ func = bsp_draw_queue;
							  params = (main, sky, 0); },
						);

						stages = (
							$brush.shader.depth_vertex,
						);
						vertexInput = {
							bindings = (
								"$brush.vertexInput.bindings[0]",
								"$brush.vertexInput.bindings[1]",
							);
							attributes = (
								"$brush.vertexInput.attributes[0]",
								"$brush.vertexInput.attributes[2]",
							);
						};
						inputAssembly = $brush.inputAssembly;
						layout = $brush.layout;
					};
					alias:depth = {
						color = $color.alias;
						tasks = (
							{ func = alias_draw;
							  params = (main, 0); },
						);

						stages = (
							$alias.shader.depth_vertex,
						);
						vertexInput = {
							// depth pass doesn't use UVs
							bindings = (
								"$alias.vertexInput.bindings[0]",
								"$alias.vertexInput.bindings[1]",
							);
							attributes = (
								"$alias.vertexInput.attributes[0]",
								"$alias.vertexInput.attributes[1]",
								"$alias.vertexInput.attributes[2]",
								"$alias.vertexInput.attributes[3]",
							);
						};
						inputAssembly = $alias.inputAssembly;
						layout = $alias.layout;
					};
					iqm:depth = {
						color = $color.iqm;
						tasks = (
							{ func = iqm_draw;
							  params = (0); },
						);

						stages = (
							$iqm.shader.depth_vertex,
						);
						vertexInput = $iqm.vertexInput;
						inputAssembly = $iqm.inputAssembly;
						layout = $iqm.layout;
					};
					sprite:depth = {
						color = $color.sprite;
						tasks = (
							{ func = sprite_draw; },
						);

						stages = (
							$sprite.shader.depth_vertex,
							$sprite.shader.depth_fragment,
						);
						vertexInput = $sprite.vertexInput;
						inputAssembly = $sprite.inputAssembly;
						layout = $sprite.layout;
					};
				};
			};
			translucent = {
				color = "[ 0.25, 0.25, 0.6, 1]";
				dependencies = {
					depth = $depth_dependency;
				};
				attachments = {
					depth = {
						depth = depth_stencil_read_only_optimal;
					};
					preserve = (color, emission, normal, position, output);
				};
				base_pipeline = {
					@inherit = $pipeline_base;
					rasterization = $cw_cull_back;
				};
				pipelines = {
					bsp:skybox = {
						color = $color.bsp;
						tasks = (
							// FIXME sky should not use OIT
							{ func = bsp_draw_queue;
							  params = (main, sky, 1); },
						);

						stages = (
							$brush.shader.quake_vertex,
							$brush.shader.skybox_fragment,
						);
						vertexInput = $brush.vertexInput;
						inputAssembly = $brush.inputAssembly;
						layout = $brush.layout;
					};
					bsp:skysheet = {
						color = $color.bsp;
						tasks = (
							// FIXME sky should not use OIT
							{ func = bsp_draw_queue;
							  params = (main, sky, 1); },
						);

						stages = (
							$brush.shader.quake_vertex,
							$brush.shader.skysheet_fragment,
						);
						vertexInput = $brush.vertexInput;
						inputAssembly = $brush.inputAssembly;
						layout = $brush.layout;
					};
					bsp:trans = {
						color = $color.bsp;
						tasks = (
							{ func = bsp_draw_queue;
							  params = (main, translucent, 1); },
							{ func = bsp_draw_queue;
							  params = (main, turbulent, 1); },
						);

						stages = (
							$brush.shader.quake_vertex,
							$brush.shader.turb_fragment,
						);
						vertexInput = $brush.vertexInput;
						inputAssembly = $brush.inputAssembly;
						layout = $brush.layout;
					};
					particles:trans = {
						color = $color.particles;
						tasks = (
							{ func = particles_draw; },
						);

						stages = (
							$particle.shader.vertex,
							$particle.shader.geometry,
							$particle.shader.fragment,
						);
						vertexInput = $particle.vertexInput;
						inputAssembly = $particle.inputAssembly;
						layout = $particle.layout.draw;
					};
					debug_lights = {
						@inherit = $compose_base;
						disabled = true;

						color = $color.lights;
						tasks = (
							{ func = lighting_bind_descriptors;
							  params = (hull, plane); },
							{ func = lighting_draw_splats; },
						);

						stages = (
							$lighting.shader.vertex_splat,
							$lighting.shader.debug_oit,
						);
						vertexInput = $lighting.vertexInput_splat;
						inputAssembly = $lighting.inputAssembly;
						layout = $lighting.splat_oit_layout;
						rasterization = $counter_cw_cull_back;
						depthStencil = $depth_test_only;
					};
				};
			};
			gbuffer = {
				color = "[ 0.3,  0.7,  0.3, 1]";
				dependencies = {
					depth = $depth_dependency;
				};
				attachments = {
					color = {
						color = {
							layout = color_attachment_optimal;
							blend = $blend_disable;
						};
						emission = {
							layout = color_attachment_optimal;
							blend = $blend_disable;
						};
						normal = {
							layout = color_attachment_optimal;
							blend = $blend_disable;
						};
						position = {
							layout = color_attachment_optimal;
							blend = $blend_disable;
						};
					};
					depth = {
						depth = depth_stencil_read_only_optimal;
					};
					preserve = (output);
				};
				base_pipeline = {
					@inherit = $pipeline_base;
					rasterization = $cw_cull_back;
				};
				pipelines = {
					bsp:gbuffer = {
						color = $color.bsp;
						tasks = (
							{ func = bsp_draw_queue;
							  params = (main, solid, 1); },
						);

						stages = (
							$brush.shader.gbuf_vertex,
							$brush.shader.gbuf_geometry,
							$brush.shader.gbuf_fragment,
						);
						vertexInput = $brush.vertexInput;
						inputAssembly = $brush.inputAssembly;
						layout = $brush.layout;
					};
					alias:gbuffer = {
						color = $color.alias;
						tasks = (
							{ func = alias_draw;
							  params = (main, 1); },
						);

						stages = (
							$alias.shader.gbuf_vertex,
							$qskin.shader.fragment,
						);
						vertexInput = $alias.vertexInput;
						inputAssembly = $alias.inputAssembly;
						layout = $alias.layout;
					};
					iqm:gbuffer = {
						color = $color.iqm;
						tasks = (
							{ func = iqm_draw;
							  params = (1); },
						);

						stages = (
							$iqm.shader.gbuf_vertex,
							$qskin.shader.fragment,
						);
						vertexInput = $iqm.vertexInput;
						inputAssembly = $iqm.inputAssembly;
						layout = $iqm.layout;
					};
					sprite:gbuffer = {
						color = $color.sprite;
						tasks = (
							{ func = sprite_draw; },
						);

						stages = (
							$sprite.shader.gbuf_vertex,
							$sprite.shader.gbuf_fragment,
						);
						vertexInput = $sprite.vertexInput;
						inputAssembly = $sprite.inputAssembly;
						layout = $sprite.layout;
					};
				};
			};
			lighting = {
				color = "[ 0.8,  0.8,  0.8, 1]";
				dependencies = {
					gbuffer = $color_dependency;
				};
				attachments = {
					input = {
						color = shader_read_only_optimal;
						emission = shader_read_only_optimal;
						normal = shader_read_only_optimal;
						position = shader_read_only_optimal;
					};
					color = {
						light = {
							layout = color_attachment_optimal;
							blend = $additive_blend;
						};
					};
					preserve = (depth, output);
				};
				pipelines = {
					lights_none = {
						@inherit = $compose_base;

						color = $color.lights;
						tasks = (
							{ func = lighting_bind_descriptors;
							  params = (main, none); },
							{ func = lighting_draw_lights;
							  params = (main, none); },
						);

						stages = (
							$fstriangle.shader.vertex,
							$lighting.shader.fragment_none,
						);
						layout = $lighting.layout;
					};
					lights_plane = {
						@inherit = $compose_base;

						color = $color.lights;
						tasks = (
							{ func = lighting_bind_descriptors;
							  params = (main, plane); },
							{ func = lighting_draw_lights;
							  params = (main, plane); },
						);

						stages = (
							$fstriangle.shader.vertex,
							$lighting.shader.fragment_plane,
						);
						layout = $lighting.layout;
					};
					lights_cascade = {
						@inherit = $compose_base;

						color = $color.lights;
						tasks = (
							{ func = lighting_bind_descriptors;
							  params = (main, cascade); },
							{ func = lighting_draw_lights;
							  params = (main, cascade); },
						);

						stages = (
							$fstriangle.shader.vertex,
							$lighting.shader.fragment_cascade,
						);
						layout = $lighting.layout;
					};
					lights_cube = {
						@inherit = $compose_base;

						color = $color.lights;
						tasks = (
							{ func = lighting_bind_descriptors;
							  params = (main, cube); },
							{ func = lighting_draw_lights;
							  params = (main, cube); },
						);

						stages = (
							$fstriangle.shader.vertex,
							$lighting.shader.fragment_cube,
						);
						layout = $lighting.layout;
					};
				};
			};
			compose = {
				color = "[ 0.7,  0.3,  0.3, 1]";
				dependencies = {
					lighting = $color_dependency;
				};
				attachments = {
					input = {
						color = shader_read_only_optimal;
						light = shader_read_only_optimal;
						emission = shader_read_only_optimal;
					};
					color = {
						output = {
							layout = color_attachment_optimal;
							blend = $additive_blend;
						};
					};
					preserve = (depth, normal, position);
				};
				pipelines = {
					compose = {
						@inherit = $compose_base;

						color = $color.compose;
						tasks = (
							{ func = compose_draw;
							  params = (0); },
						);

						stages = (
							$fstriangle.shader.vertex,
							$compose.shader.fragment,
						);
						layout = $compose.layout;
					};
					debug_bsp = {
						@inherit = $compose_base;
						disabled = true;

						color = $color.bsp;
						tasks = (
							{ func = bsp_visit_world;
							  params = (debug); },
							{ func = bsp_draw_queue;
							  params = (debug, solid, 0); },
							{ func = bsp_draw_queue;
							  params = (debug, sky, 0); },
							{ func = bsp_draw_queue;
							  params = (debug, translucent, 0); },
							{ func = bsp_draw_queue;
							  params = (debug, turbulent, 0); },
						);

						stages = (
							$brush.shader.depth_vertex,
							$brush.shader.debug_fragment,
						);
						vertexInput = {
							bindings = (
								"$brush.vertexInput.bindings[0]",
								"$brush.vertexInput.bindings[1]",
							);
							attributes = (
								"$brush.vertexInput.attributes[0]",
								"$brush.vertexInput.attributes[2]",
							);
						};
						inputAssembly = $brush.inputAssembly;
						layout = $brush.layout;
						rasterization = $debug_poly_lines;
						depthStencil = $depth_disable;
					};
					debug_lights = {
						@inherit = $compose_base;
						disabled = true;

						color = $color.lights;
						tasks = (
							{ func = lighting_bind_descriptors;
							  params = (hull, none); },
							{ func = lighting_draw_splats; },
						);

						stages = (
							$lighting.shader.vertex_splat,
							$lighting.shader.debug_fragment,
						);
						vertexInput = $lighting.vertexInput_splat;
						inputAssembly = $lighting.inputAssembly;
						layout = $lighting.splat_layout;
						rasterization = $debug_poly_lines;
						depthStencil = $depth_disable;
					};
					debug_planes = {
						@inherit = $compose_base;
						disabled = true;

						color = $color.lights;
						tasks = (
							{ func = debug_planes_draw; },
						);

						stages = (
							$fstriangle.shader.vertexst,
							$gridplane.shader.fragment,
						);
						layout = $gridplane.layout;
						depthStencil = $depth_disable;
					};
				};
			};
			entid = {
				color = "[ 1,  0,  0, 1]";
				dependencies = {
					depth = $depth_dependency;
				};
				attachments = {
					color = {
						entid = {
							layout = color_attachment_optimal;
							blend = $blend_disable;
						};
					};
					preserve = (depth, normal, position, output);
				};
				pipelines = {
					entid_lights = {
						@inherit = $compose_base;
						disabled = false;

						color = $color.lights;
						tasks = (
							{ func = lighting_bind_descriptors;
							  params = (hull, none); },
							{ func = lighting_draw_splats; },
						);

						stages = (
							$lighting.shader.vertex_entid,
							$general.shader.fragment_entid,
						);
						vertexInput = $lighting.vertexInput_splat;
						inputAssembly = $lighting.inputAssembly;
						layout = $lighting.splat_layout;
						rasterization = $debug_poly_lines;
						depthStencil = $depth_disable;
					};
				};
			};
		};
		output = output;
	};
	deferred_cube = {
		@inherit = $renderpasses.deferred;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3fu, 0x3fu, 0x3fu, 0x3fu, 0x3fu, 0x3fu);
		});
		framebuffer = {
			width = "min($render_output.extent.width,$render_output.extent.height)";
			height = "min($render_output.extent.width,$render_output.extent.height)";
			layers = 1;
			attachments = {
				depth = {
					@inherit = $attachment_base;
					format = $images.cube_depth.format;
					loadOp = clear;
					finalLayout = depth_stencil_attachment_optimal;
					clearValue = { depthStencil = { depth = 0; stencil = 0; }; };
					view = cube_depth;
				};
				color = {
					@inherit = $attachment_base;
					format = $images.cube_color.format;
					loadOp = clear;
					view = cube_color;
				};
				emission = {
					@inherit = $attachment_base;
					format = $images.cube_emission.format;
					loadOp = clear;
					view = cube_emission;
				};
				normal = {
					@inherit = $attachment_base;
					format = $images.cube_normal.format;
					view = cube_normal;
				};
				position = {
					@inherit = $attachment_base;
					format = $images.cube_position.format;
					view = cube_position;
				};
				light = {
					@inherit = $attachment_base;
					format = $images.cube_light.format;
					view = cube_light;
				};
				entid = {
					@inherit = $attachment_base;
					format = $images.cube_entid.format;
					loadOp = clear;
					storeOp = store;
					finalLayout = transfer_src_optimal;
					clearValue = {
						color = { int32 = ( -1, -1, -1, -1); };
					};
					view = cube_entid;
				};
				output = {
					@inherit = $attachment_base;
					format = $render_output.format;
					loadOp = clear;
					storeOp = store;
					finalLayout = $render_output.finalLayout;
					view = cube_output;
				};
			};
		};
		output = cube_output;
	};
	output = {
		color = "[0, 1, 1, 1]";
		framebuffer = {
			layers = 1;
			attachments = {
				output = $swapchain;
			};
		};
		subpasses = {
			compose = {
				color = "[ 0,  0.5,  0.5, 1]";
				attachments = {
					color = {
						output = {
							layout = color_attachment_optimal;
							blend = $alpha_blend;
						};
					};
				};
				pipelines = {
					output = {
						@inherit = $compose_base;

						color = $color.output;
						tasks = (
							{ func = output_draw_flat; },
						);

						stages = (
							$fstriangle.shader.vertex,
							$output.shader.fragment,
						);
						layout = $output.layout;
					};
					waterwarp = {
						@inherit = $compose_base;
						disabled = true;

						color = $color.output;
						tasks = (
							{ func = output_draw_waterwarp; },
						);

						stages = (
							$fstriangle.shader.vertexst,
							$waterwarp.shader.fragment,
						);
						layout = $waterwarp.layout;
					};
					fisheye = {
						@inherit = $compose_base;
						disabled = true;

						color = $color.output;
						tasks = (
							{ func = output_draw_fisheye; },
						);

						stages = (
							$fstriangle.shader.vertexst,
							$fisheye.shader.fragment,
						);
						layout = $fisheye.layout;
					};
					slice = {
						@inherit = $compose_base;

						color = $color.slice;
						tasks = (
							{ func = slice_draw; },
						);

						stages = (
							$slice.shader.vertex,
							$slice.shader.fragment,
						);
						vertexInput = $slice.vertexInput;
						inputAssembly = $slice.inputAssembly;
						layout = $slice.layout;
					};
					lines = {
						@inherit = $compose_base;

						color = $color.lines;
						tasks = (
							{ func = line_draw; },
						);

						stages = (
							$lines.shader.vertex,
							$lines.shader.fragment,
						);
						vertexInput = $lines.vertexInput;
						inputAssembly = $lines.inputAssembly;
						layout = $lines.layout;
					};
				};
			};
		};
	};
	shadow = {
		color = "[0.2, 0.2, 0.2, 1]";
		framebuffer = {
			layers = 1;
			attachments = {
				shadow = $shadow;
			};
		};
		subpasses = {
			shadow = {
				color = "[ 0.5,  0.5,  0.5, 1]";
				attachments = {
					depth = {
						shadow = transfer_src_optimal;
					};
				};

				base_pipeline = {
					@inherit = $pipeline_base;
					depthStencil = $depth_test_and_write;
					rasterization = $cw_cull_front;
				};
				pipelines = {
					bsp:shadow = {
						color = $color.bsp;
						tasks = (
							{ func = bsp_draw_queue;
							  params = (shadow, solid, 0); },
						);

						stages = (
							$brush.shader.shadow_vertex,
						);
						vertexInput = {
							bindings = (
								"$brush.vertexInput.bindings[0]",
								"$brush.vertexInput.bindings[1]",
							);
							attributes = (
								"$brush.vertexInput.attributes[0]",
								"$brush.vertexInput.attributes[2]",
							);
						};
						inputAssembly = $brush.inputAssembly;
						layout = $brush.shadow_layout;
					};
					alias:shadow = {
						color = $color.alias;
						tasks = (
							{ func = alias_draw;
							  params = (shadow, 0); },
						);

						stages = (
							$alias.shader.shadow_vertex,
						);
						vertexInput = {
							// depth/shadow pass doesn't use UVs
							bindings = (
								"$alias.vertexInput.bindings[0]",
								"$alias.vertexInput.bindings[1]",
							);
							attributes = (
								"$alias.vertexInput.attributes[0]",
								"$alias.vertexInput.attributes[1]",
								"$alias.vertexInput.attributes[2]",
								"$alias.vertexInput.attributes[3]",
							);
						};
						inputAssembly = $alias.inputAssembly;
						layout = $alias.shadow_layout;
					};
					iqm:shadow = {
						color = $color.iqm;
						tasks = (
							{ func = iqm_draw;
							  params = (0); },
						);

						stages = (
							$iqm.shader.shadow_vertex,
						);
						vertexInput = $iqm.vertexInput;
						inputAssembly = $iqm.inputAssembly;
						layout = $iqm.shadow_layout;
					};
				};
			};
		};
	};
	shadow2 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x03u);
		});
	};
	shadow3 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x07u);
		});
	};
	shadow4 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x0fu);
		});
	};
	shadow5 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x1fu);
		});
	};
	shadow6 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3fu);
		});
	};
	shadow7 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x7fu);
		});
	};
	shadow8 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0xffu);
		});
	};
	shadow9 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x1ffu);
		});
	};
	shadow10 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3ffu);
		});
	};
	shadow11 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x7ffu);
		});
	};
	shadow12 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0xfffu);
		});
	};
	shadow13 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x1fffu);
		});
	};
	shadow14 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3fffu);
		});
	};
	shadow15 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x7fffu);
		});
	};
	shadow16 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0xffffu);
		});
	};
	shadow17 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x1ffffu);
		});
	};
	shadow18 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3ffffu);
		});
	};
	shadow19 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x7ffffu);
		});
	};
	shadow20 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0xfffffu);
		});
	};
	shadow21 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x1fffffu);
		});
	};
	shadow22 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3fffffu);
		});
	};
	shadow23 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x7fffffu);
		});
	};
	shadow24 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0xffffffu);
		});
	};
	shadow25 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x1ffffffu);
		});
	};
	shadow26 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3ffffffu);
		});
	};
	shadow27 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x7ffffffu);
		});
	};
	shadow28 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0xfffffffu);
		});
	};
	shadow29 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x1fffffffu);
		});
	};
	shadow30 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x3fffffffu);
		});
	};
	shadow31 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0x7fffffffu);
		});
	};
	shadow32 = {
		@inherit = $renderpasses.shadow;
		@next = (VkRenderPassMultiviewCreateInfo, {
			viewMasks   = (0xffffffffu);
		});
	};
};
steps = {
	wait_on_fence = {
		color = "[0.6, 0.8, 0.0]";
		process = {
			tasks = (
				{ func = wait_on_fence; },
				{ func = capture_finalize; },
				{ func = mousepick_finalize; },
				{ func = update_matrices; },
				{ func = draw_scr_funcs; },
			);
		};
	};
	particles = {
		color = "[0.6, 0.8, 0.9]";
		dependencies = (wait_on_fence);
		compute = {
			pipelines = {
				part:update = {
					color = "[0.3, 0.8, 0.9]";
					tasks = (
						{ func = update_particles; }
					);
					stage = {
						name = main;
						module = $builtin/partupdate.comp;
					};
					layout = $particle.layout.update;
				};
				part:physics = {
					color = "[0.6, 0.8, 0.9]";
					tasks = (
						{ func = particle_physics; }
					);
					stage = {
						name = main;
						module = $builtin/partphysics.comp;
					};
					layout = $particle.layout.physics;
				};
			};
		};
	};
	world = {
		color = "[0.3, 0.4, 0.0]";
		dependencies = (wait_on_fence);
		process = {
			tasks = (
				{ func = bsp_reset_queues; },
				{ func = bsp_visit_world;
				  params = (main); },
				{ func = scene_draw_viewmodel; },
				{ func = lighting_update_lights; },
			);
		};
	};
	light_cull = {
		color = "[0.8, 0.6, 0, 1]";
		dependencies = (world);
		process = {
			tasks = (
				{ func = lighting_cull_select_renderpass;
				  params = ("\"light_cull\""); },
				{ func = update_framebuffer;
				  params = ("\"light_cull\""); },
				{ func = lighting_cull_lights;
				  params = ("\"light_cull\""); },
			);
		};
		render = {
			renderpasses = {
				occlusion = $renderpasses.occlusion;
				occlusion_cube = $renderpasses.occlusion_cube;
			};
		};
	};
	shadow = {
		color = "[0.3, 0.3, 0.3]";
		dependencies = (light_cull);
		process = {
			tasks = (
				{ func = lighting_setup_shadow; },
				{ func = bsp_visit_world;
				  params = (shadow); },
				{ func = lighting_draw_shadow_maps;
				  params = ("\"shadow\""); },
			);
		};
		render = {
			renderpasses = {
				shadow = $renderpasses.shadow;
				shadow2 = $renderpasses.shadow2;
				shadow3 = $renderpasses.shadow3;
				shadow4 = $renderpasses.shadow4;
				shadow5 = $renderpasses.shadow5;
				shadow6 = $renderpasses.shadow6;
				shadow7 = $renderpasses.shadow7;
				shadow8 = $renderpasses.shadow8;
				shadow9 = $renderpasses.shadow9;
				shadow10 = $renderpasses.shadow10;
				shadow11 = $renderpasses.shadow11;
				shadow12 = $renderpasses.shadow12;
				shadow13 = $renderpasses.shadow13;
				shadow14 = $renderpasses.shadow14;
				shadow15 = $renderpasses.shadow15;
				shadow16 = $renderpasses.shadow16;
				shadow17 = $renderpasses.shadow17;
				shadow18 = $renderpasses.shadow18;
				shadow19 = $renderpasses.shadow19;
				shadow20 = $renderpasses.shadow20;
				shadow21 = $renderpasses.shadow21;
				shadow22 = $renderpasses.shadow22;
				shadow23 = $renderpasses.shadow23;
				shadow24 = $renderpasses.shadow24;
				shadow25 = $renderpasses.shadow25;
				shadow26 = $renderpasses.shadow26;
				shadow27 = $renderpasses.shadow27;
				shadow28 = $renderpasses.shadow28;
				shadow29 = $renderpasses.shadow29;
/* FIXME bug in nvidia drivers causes segfault when building the pipelines
				shadow30 = $renderpasses.shadow30;
				shadow31 = $renderpasses.shadow31;
				shadow32 = $renderpasses.shadow32;
*/
			};
		};
	};
	setup_main = {
		color = "[0.3, 0.8, 0.3]";
		dependencies = (wait_on_fence);
		process = {
			tasks = (
				{ func = output_select_renderpass;
				  params = ("\"main\""); },
				{ func = update_framebuffer;
				  params = ("\"main\""); },
				{ func = clear_translucent;
				  params = ("\"main\""); },
				{ func = particle_wait_physics; },
				{ func = lighting_update_descriptors;
				  params = ("\"main\""); },
			);
		};
	};
	main = {
		color = "[0.3, 0.8, 0.0]";
		dependencies = (setup_main, particles, shadow, world);
		render = {
			renderpasses = {
				deferred = $renderpasses.deferred;
				deferred_cube = $renderpasses.deferred_cube;
			};
		};
	};
	preoutput = {
		color = "[0.8, 0.8, 0.0]";
		dependencies = (wait_on_fence);
		process = {
			tasks = (
				{ func = acquire_output;
				  params = ("\"output\""); },
				{ func = update_input;
				  params = ("\"main\""); },
				{ func = output_select_pipeline;
				  params = ("\"output\""); },
				{ func = flush_draw; },
			);
		};
	};
	output = {
		color = "[0.4, 0.8, 0.4]";
		dependencies = (main, preoutput);
		render = {
			renderpasses = {
				output = $renderpasses.output;
			};
		};
	};
	capture = {
		color = "[0.0, 0.8, 0.4]";
		dependencies = (output);
		process = {
			tasks = (
				{ func = capture_initiate; },
			);
		};
	};
	mouse_pick = {
		color = "[0.0, 0.0, 0.8]";
		dependencies = (main);
		process = {
			tasks = (
				{ func = mousepick_initiate; },
			);
		};
	};
};
